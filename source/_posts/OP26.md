---
title: 【OP26】NC-秘密构成
date: 2022-05-23
tag: [dp]
category: [One Problem]
math: true
---


dp

<!--more--> 

题目链接：[秘密构成](https://ac.nowcoder.com/acm/contest/11180/E)

首先容易想到 $O(n^2)$ 的暴力做法，令 $dp[i]$ 表示到 $i$ 为止的最大价值，那么 $dp[i]=\max\lbrace dp[j]+F(i,j) \rbrace$。

然后注意到 $500$ 的值域，似乎暗示了优化的方向。我们没必要每次从 $1$ 到 $i-1$ 去枚举 $j$。不妨定义状态 $f[x][y]$ 表示以 $x$ 结尾，下一个数是 $y$ 时的最大值，每次经过一个新的 $i$ 之后，只有 $f[a[i]][]$ 的状态可能发生改变，以其他的值结尾的状态都不会发生改变。那就可以在转移的时候计算出后面的数的 $500$ 种可能性更新 $f[a[i]][]$，将来直接在 $f[][a[i]]$ 里查找即可。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 5;
ll A, B;
ll h(ll x) {
	return A * (x % 100) * (x % 100) + B * x;
}
ll a[N], b[N], dp[N], f[505][505];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin >> n >> A >> B;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	for (int i = 1; i <= n; ++i)
		cin >> b[i];
	memset(f, -0x3f, sizeof(f));
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= 500; ++j) 
			dp[i] = max(dp[i], f[j][a[i]] + h(j * b[i]));
		for (int j = 1; j <= 500; ++j) 
			f[a[i]][j] = max(f[a[i]][j], dp[i] - h(b[i] * j));
	}
	ll ans = *max_element(dp + 1, dp + n + 1);
	cout << ans << endl;
	return 0;
}
```

