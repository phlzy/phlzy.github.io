---
title: 【OP17】[HAOI2011]problem a
date: 2022-04-07
tag: [dp]
category: [One Problem]
math: true
---


dp

<!--more-->

题目链接：[洛谷P2519](https://www.luogu.com.cn/problem/P2519)
[BZOJ2298](https://hydro.ac/d/bzoj/p/2298)

最小化说谎的人数，就相当于最大化说真话的人数。如果一个人说有 $a$ 个人分数比他高，$b$ 个人分数比他低，显然他的排名应当位于 $[a+1,n-b]$。现在问题转化为数轴上有若干个线段，问最多有多少条线段不相交。这可以用 dp 解决，$dp[i]$ 表示到 $i$ 为止最多不相交的线段个数，枚举在 $i$ 处结尾的线段，从它起始位置的前一格处进行转移。总复杂度 $O(n\log n)$。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;
const int maxn = 1e5 + 5;
map<pii, int> cnt;
vector<int> seg[maxn];
int dp[maxn];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    for (int i = 1, l, r; i <= n; ++i) {
        cin >> l >> r;
        l++, r = n - r;
        if (r > l)
            continue;
        cnt[{l, r}]++;
        if (cnt[{l, r}] == 1)
            seg[r].push_back(l);
    }
    for (int i = 1; i <= n; ++i) {
        dp[i] = dp[i - 1];
        for (auto &&l : seg[i]) {
            dp[i] = max(dp[i], dp[l - 1] + min(i - l + 1, cnt[{l, i}]));
        }
    }
    cout << n - dp[n] << endl;
    return 0;
}
```

