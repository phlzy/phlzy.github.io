---
title: 【OP29】一人行者
date: 2022-09-03
tag: [dp]
category: [One Problem]
math: true
---

换根dp

<!--more-->

牛客练习赛 102D：[一人行者](https://ac.nowcoder.com/acm/contest/39759/D)

本来不想为了这题写一篇博客的，但因为昨天被一组数据卡了一个小时，还是有必要来记录一下。

> 这篇本来想写另一个题的，但是原稿找不到了，只剩这一点片段：
>
> 只考虑值发生变化的位置。
>
> 先固定段数 $i\in[1,n]$，如果要分成 $i$ 段，有 $\binom{n-1}{i-1}$ 种分法。
>
> 然后考虑最大值，显然，如果分为 $i$ 段，最大值 $j\ge i-1$。
>
> 固定了最大值后，有 $\binom{k-1}{j-1}$ 种取法。
>
> $$
> \sum_{i=1}^{n}\binom{n-1}{i-1}\sum_{j=i-1}^{k}\binom{j}{i-1}j
> \\
> =\sum_{i=1}^{n}\binom{n-1}{i-1}\bigg(i\sum_{j=i-1}^{k}\binom{j+1}{i}-\sum_{j=i-1}^{k}\binom{j+1}{i}\bigg)
> $$
> 
> 已经无法确定这是什么东西了。



题意是给一棵树，求断掉每一条边后得到的两棵树各自的联通子集数量，对 $998244353$ 取模。

容易想到树形 dp，令 $dp[u][0/1]$ 表示 $u$ 的子树中是否包含 $u$ 的子集数量，显然有状态转移方程：

$$
\left\{ \begin{array}{l}
dp[u][0]=\sum (dp[v][0]+dp[v][1])\\
dp[u][1]=\prod (1+dp[v][1])
\end{array} \right.
$$

其中 $v$ 是 $u$ 的子节点。

然后考虑断边的操作，假设断的边是 $(u,v)$，其中 $v$ 是儿子，那么 $v$ 所在的子树的答案 $V=dp[v][0]+dp[v][1]$，而 $u$ 所在的树的答案是总的联通子集个数减去 $V$ 再减去以 $v$ 作为中间节点的联通子集个数。那么还需要求出每个节点“向上的子树”中联通子集的个数，其实就是换根 dp，重新进行一次 dfs 后自上而下计算即可。

于是我交了一份这样的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using std::cin;
using std::cout;
using std::string;
#define endl '\n'
#define TRACE(x) std::cerr << #x << " = " << x << endl
#define fi first
#define se second
#define pb push_back

using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
using pii = std::pair<int, int>;

constexpr int maxn = 5e5 + 5;
constexpr int inf = 0x3f3f3f3f;
constexpr ll mod = 998244353;
template <uint MOD = mod> struct mint {
    uint x;
    mint() : x(0) {}
    mint(ll _x) {
        _x %= MOD;
        if (_x < 0)
            _x += MOD;
        x = _x;
    }
    explicit operator int() const { return x; } 
    mint &operator+=(const mint &a) {
        x += a.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }
    mint &operator-=(const mint &a) {
        x += MOD - a.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }
    mint &operator*=(const mint &a) {
        x = (ull)x * a.x % MOD;
        return *this;
    }
    mint pow(ll pw) const {
        mint res = 1;
        mint cur = *this;
        while (pw) {
            if (pw & 1)
                res *= cur;
            cur *= cur;
            pw >>= 1;
        }
        return res;
    }
    mint inv() const {
        assert(x != 0);
        uint t = x;
        uint res = 1;
        while (t != 1) {
            uint z = MOD / t;
            res = (ull)res * (MOD - z) % MOD;
            t = MOD - t * z;
        }
        return res;
    }
    mint &operator/=(const mint &a) { return *this *= a.inv(); }
    mint operator+(const mint &a) const { return mint(*this) += a; }
    mint operator-(const mint &a) const { return mint(*this) -= a; }
    mint operator*(const mint &a) const { return mint(*this) *= a; }
    mint operator/(const mint &a) const { return mint(*this) /= a; }
    bool operator==(const mint &a) const { return x == a.x; }
    bool operator!=(const mint &a) const { return x != a.x; }
    bool operator<(const mint &a) const { return x < a.x; }
    friend std::istream &operator>>(std::istream &is, mint &a) {
        ll v;
        is >> v;
        a = mint(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const mint &a) {
        return os << a.x;
    }
};

int fa[maxn];
pii q[maxn];
vector<int> g[maxn];
using Z = mint<998244353>;
Z dp[2][maxn];
void dfs(int u, int f) {
    fa[u] = f;
    dp[1][u] = 1;
    for (auto& v : g[u]) {
        if (v == f) continue;
        dfs(v, u);
        dp[0][u] += dp[0][v] + dp[1][v];
        dp[1][u] *= (dp[1][v] + 1);
    }
}
Z up[maxn];
void dfs1(int u, int f) {
    if (f) {
        up[u] = (up[f] + 1) * dp[1][f] / (dp[1][u] + 1);
    }
    for (auto& v : g[u]) {
        if (v == f) continue;
        dfs1(v, u);
    }
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
        q[i] = {u, v};
    }
    dfs(1, 0);
    dfs1(1, 0);
    for (int i = 1; i < n; ++i) {
        auto [u, v] = q[i];
        bool f = 0;
        if (fa[u] == v) {
            f = 1;
            swap(u, v);
        }
        Z V = dp[0][v] + dp[1][v];
        Z U = dp[0][1] + dp[1][1] - V - up[v] * dp[1][v];
        if (f) swap(U, V);
        cout << U << " " << V << endl;
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    for (int cas = 1; cas <= T; ++cas) {
        solve();
    }
    return 0;
}
```

这份代码有一个问题，你能看出来吗？

提示：问题出在 dp 的过程中

提示2：`mint` 类没有任何问题，也没有数组越界，但是 RE 了

答案很简单。

注意第 105 行。

当 $dp[1][u]=mod-1$ 的时候，这里就出问题了。

之前的思路都是正确的，只要避免这里除零的问题，就可以得到正确的答案了。所以记录一下前后缀积就行了。

昨晚调了一个小时也没发现是这里的问题。不过看起来[不止我一个人](https://ac.nowcoder.com/discuss/1038340)在这里被卡了。

以后再用乘法逆元的时候，一定要考虑清楚会不会产生除 $0$ 的情况。
