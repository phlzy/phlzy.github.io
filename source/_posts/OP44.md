---
title: 【OP44】【Resuscitated】CF-Resourceful Caterpillar Sequence
date: 2025-03-31
tag: [ad-hoc, tree]
category: [One Problem]
math: true
---

The series paused after 43 entries in 2023. It resumes here.

<!--more-->

> *One Problem* began as a collection of problems that were interesting not because of their algorithms, but because of the ideas behind them. Many required little machinery and much thought.
>
> The series paused after 43 entries in 2023. It resumes here.
>
> The intention remains unchanged: record problems worth thinking about. Updates will continue to be irregular. Some earlier posts have reverted to draft versions due to infrastructure changes; they will remain so for now.
>
> We proceed with #44.
>
> Feb. 2026
>
> Schwarz


题目链接：[Resourceful Caterpillar Sequence](https://codeforces.com/contest/2053/problem/E)

一棵树有 $n$ 个节点，定义一个 *caterpillar* （毛毛虫）为树上的一个点对 $(p,q)$ 之间形成的简单路径上的所有点，其中 *caterpillar* 的头部为 $p$，尾部为 $q$。

caterpillar 序列是将这条路径上的点形成的序列按照到p的距离升序排列的

Nora 和 Aron 两个人轮流在树上拉动毛毛虫，Nora 选择 $p$ 的一个相邻且不在毛毛虫上的顶点 $p^*$，将头部移到 $p^*$，并将所有其他点往 $p$ 的方向移动一条边。Aron 则往 $q$ 的方向移动。谁把头部/尾部移动到叶子上谁就赢，如果双方都赢不了，或者首尾都在叶子上，则平局。Nora 先手。双方都采取最优策略，想要自己获胜并阻止对方获胜。

计算树上所有点对 $(p,q),p\neq q$ 中，Aron 获胜的局面数量。

## Solution

首先不难发现，如果头尾离叶子比较远，那么两边可以互相把虫子拉回去，这时候是平局。

具体来说，如果前两次操作没有分出胜负，那么永远都不会有结果了。

那么树上的点就可以分成三类：

1. 叶子（A）
2. 与叶子相邻的非叶子节点（B）
3. 其他节点（C）

那么后手什么时候会赢？

1. 后手在 A 上，先手在 B 或 C 上
2. 先手在 C 上，并且会把尾巴拉到 B 上

统计这两种情况：

第一种情况很简单，统计叶子数量即可。

第二种情况直接算太复杂。这是因为，如果只考虑 $q$ 的性质，那么 $q$ 应该是**无论往什么方向移动，都会走到 B 类节点**的节点。这样统计是很麻烦的，但是，$q$ 的移动方向真的是任意的吗？注意到，在先手一方移动 $p$ 的时候，$q$ 只会往 $p,q$ 的路径上移动。即，在 $p,q$ 确定后不管 $p$ 往什么方向移动，$q$ 的方向是唯一的，就是他的前驱节点。

那么，$q$ 的前驱节点 $m$ 有什么性质呢？首先 $m$ 显然不是叶子。其次，$m$ 必须与叶子相邻。那么确定了 $m$ 和 $p$ 后，$q$ 的选择方案就是从所有与 $m$ 相邻的非叶子节点中去掉 $p\to m$ 路径上的那一个点，这就很好统计了。

## Code

``` cpp
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;
using std::min;
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;
using pii = std::pair<int, int>;
const int inf = 0x3f3f3f3f;
const int maxn = 2e5 + 5;

vector<int> g[maxn];

void solve() {
    int n;
    cin >> n;
    for (int i = 1, u, v; i < n; ++i) {
    	cin >> u >> v;
    	g[v].push_back(u);
    	g[u].push_back(v);
    }
    int A = 0, B = 0, C = 0;
    ll ans = 0;
	for (int i = 1; i <= n; ++i) 
		A += (g[i].size() == 1); // 叶子节点数量
	ans += 1ll * A * (n - A);
	vector<int> cnt(n + 1, 0); // 相邻的非叶节点数量
	for (int i = 1; i <= n; ++i) {
		if (g[i].size() > 1) {
			for (int j : g[i]) {
				cnt[i] += (g[j].size() > 1);
			}
		}
		C += (cnt[i] == g[i].size());
	}

	for (int m = 1; m <= n; ++m) {
		if (g[m].size() > 1 && cnt[m] != g[m].size()) {
			ans += 1ll * C * (cnt[m] - 1);
		}
	}
	cout << ans << '\n';
    for (int i = 1; i <= n; ++i) {
    	g[i].clear();
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        solve();
    }
    return 0;
}
```