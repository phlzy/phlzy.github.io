---
title: 【OP47】LC-Special Binary String
date: 2026-02-20
tag: [Elixir, recursion]
category: [One Problem]
math: true
---

递归

<!--more-->

[题目链接](https://leetcode.cn/problems/special-binary-string/description/)

经典问题，特殊二进制序列的定义有两个条件：

1. `0` 和 `1` 的数量相等。
2. 任何前缀中 `1` 的数量都不低于 `0` 的数量。

那么这其实就是一个括号序列，可以任意交换相当于可以排序。所以可以分治，字典序降序排序所有独立的括号序列，对于每个括号序列内部递归的进行处理。

常见的实现是这样的：
``` python
class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        if len(s) <= 2:
            return s
        
        cnt = left = 0
        subs = []

        for i, ch in enumerate(s):
            if ch == "1":
                cnt += 1
            else:
                cnt -= 1
                if cnt == 0:
                    subs.append("1" + self.makeLargestSpecial(s[left + 1 : i]) + "0")
                    left = i + 1
        
        subs.sort(reverse=True)
        return "".join(subs)
```



那么，如何用 Elixir 实现？

``` elixir
defmodule Solution do
  @spec make_largest_special(s :: String.t()) :: String.t()
  
  # 基础情况：空字符串直接返回
  def make_largest_special(""), do: ""
  
  def make_largest_special(s) do
    s
    |> split_specials(0, "", []) # 1. 将字符串拆分为独立的特殊子串列表
    |> Enum.map(fn special ->
      # 2. 剥离首尾的 1 和 0
      inner_len = byte_size(special) - 2
      <<?1, inner::binary-size(inner_len), ?0>> = special
      
      # 递归处理内部，并重新拼装
      "1" <> make_largest_special(inner) <> "0"
    end)
    |> Enum.sort(:desc)          # 3. 按字典序降序排列
    |> Enum.join()               # 4. 重新拼接成单个字符串
  end

  # ==========================================
  # 辅助函数：用尾递归来替代 Python 中的 for 循环
  # 参数说明: (剩余字符串, 当前的 count, 当前正在构建的子串, 收集完毕的子串列表 acc)
  # ==========================================
  
  # 递归终点：字符串为空时，返回收集好的列表（因为是往头部插入，所以要 reverse 一下）
  defp split_specials("", _count, _current, acc), do: Enum.reverse(acc)
  
  # 递归主体：匹配字符串的第一个字符 `char`，剩下的部分归入 `rest`
  defp split_specials(<<char, rest::binary>>, count, current, acc) do
    # ?1 和 ?0 是 Elixir 中获取字符 ASCII 码的写法
    new_count = if char == ?1, do: count + 1, else: count - 1
    new_current = current <> <<char>>

    if new_count == 0 do
      # 找到了一个完整的特殊子串，将它放入累加器 acc，重置状态继续处理 rest
      split_specials(rest, 0, "", [new_current | acc])
    else
      # 还未闭合，带着更新后的状态继续递归
      split_specials(rest, new_count, new_current, acc)
    end
  end
end
```

这里主要值得学习的是模式匹配与尾递归：

## 模式匹配

这行代码 `<<?1, inner::binary-size(inner_len), ?0>> = special` 并不是赋值，它是**模式匹配**。

你可以把左边的 `<<...>>` 想象成一个**定制的模具**，我们硬要把右边的 `special` 字符串往这个模具里塞。

模具有三个隔间：

1. **第一个隔间 `?1`**：
   - `?1` 是 Elixir 写法，表示字符 `'1'` 的 ASCII 码值（也就是整数 49）。
   - **含义**：它要求 `special` 的**第一个字节**必须是 `'1'`。如果不是，匹配直接报错（Crash）。
2. **第二个隔间 `inner::binary-size(inner_len)`**：
   - 这是最关键的部分！
   - `inner`：这是我们要提取出来的变量名。
   - `::binary`：告诉 Elixir，这一段数据是二进制（字符串），不是整数，也不是浮点数。
   - `-size(inner_len)`：**定长截取**。告诉 Elixir：“从这里开始，往后数 `inner_len` 个字节，把这些字节统统剪下来，贴上标签叫 `inner`。”
3. **第三个隔间 `?0`**：
   - **含义**：截取完中间的内容之后，要求**剩下的最后一个字节**必须是 `'0'`。


这就涉及到了 Elixir 的哲学和性能：

1. **断言（Assertion）功能**： 这种写法不仅是“提取”，还是“检查”。如果传入的特殊子串**不是**以 1 开头、0 结尾（比如代码逻辑错了），这行代码会直接抛出 `MatchError`。在递归算法中，这种“Fail Fast（快速失败）”能帮你瞬间定位 Bug，而不是算出错误结果让你猜。
2. **性能（零拷贝视图）**： 这是最硬核的。`String.slice` 可能会产生新的子字符串拷贝。 而二进制模式匹配生成的 `inner`，在 Erlang VM 内部通常是一个 **Sub-binary（子二进制）**。它只是一个指向原字符串内存中间一段的**指针（引用）**，加上长度标记。 **它不复制内存！** 这就是为什么在处理巨大字符串时，Elixir 的这种写法快得飞起。

总结图解：


```
代码:  << ?1,  inner::binary-size(len),  ?0 >>  =  "11011000"
        |    |                       |
        |    +-----------+-----------+
        |                |
映射:   [49]  [ ...... inner ...... ]  [48]
        (1)          (中间的数据)         (0)
```



## 尾递归

所有的 `for` 和 `while` 循环都可以被它完美替代。

```elixir
# 1. 递归终点（Base Case）
defp split_specials("", _count, _current, acc), do: Enum.reverse(acc)

# 2. 递归主体（Recursive Step）
defp split_specials(<<char, rest::binary>>, count, current, acc) do
  new_count = if char == ?1, do: count + 1, else: count - 1
  new_current = current <> <<char>>

  if new_count == 0 do
    split_specials(rest, 0, "", [new_current | acc])
  else
    split_specials(rest, new_count, new_current, acc)
  end
end
```

在 Elixir 中，数据是**不可变（Immutable）**的。你不能写 `count = count + 1`。那么状态怎么更新呢？**答案是：把旧状态算成新状态，然后作为参数传给“下一个自己”。**

你看 `split_specials` 的四个参数，它们完美对应了 Python 里的循环状态：

1. `<<char, rest::binary>>`：当前要看的字符 `char`，以及**剩下的字符串 `rest`**（这代替了 `for` 循环的迭代）。
2. `count`：当前的计数器。
3. `current`：当前正在拼凑的特殊子串。
4. `acc`（Accumulator，累加器）：用来装已经找齐的特殊子串的大框。

> 为了让你彻底看懂，我们拿一个最短的特殊字符串 `s = "10"`，看看它是怎么在这几个函数之间“穿梭”的。
>
> **初始调用**：`split_specials("10", 0, "", [])`
>
> #### 第 1 步：处理字符 `1`
>
> - Elixir 看到 `"10"`，通过模式匹配 `<<char, rest::binary>>` 把它拆成了 `char = ?1` (字符 '1')，`rest = "0"`。
>
> - 此时传入的 `count = 0`, `current = ""`, `acc = []`。
>
> - 开始计算新状态：
>
>   - 因为 `char` 是 `?1`，所以 `new_count = 0 + 1 = 1`。
>   - `new_current = "" <> "1" = "1"`（`<>` 是 Elixir 的字符串拼接）。
>
> - 判断：`new_count` 是 0 吗？不是（现在是 1）。说明当前这个子串还没闭合。
>
> - **发起递归**：带着新状态，去调用下一个自己：
>
>   `split_specials("0", 1, "1", [])`
>
> #### 第 2 步：处理字符 `0`
>
> - 现在的参数变成了：剩余字符串是 `"0"`，`count = 1`，`current = "1"`，`acc = []`。
>
> - 模式匹配把 `"0"` 拆成：`char = ?0` (字符 '0')，`rest = ""` (空字符串)。
>
> - 开始计算新状态：
>
>   - 因为 `char` 不是 `?1`，所以 `new_count = 1 - 1 = 0`。
>   - `new_current = "1" <> "0" = "10"`。
>
> - 判断：`new_count` 是 0 吗？**是的！是 0！** 这意味着我们找到了一个完整的闭合特殊子串 `"10"`。
>
> - **发起递归**：既然当前子串找齐了，我们把它塞进 `acc` 里。重置 `count` 和 `current`，继续处理剩下的字符串：
>
>   `split_specials("", 0, "", ["10" | []])`  ->  也就是 `split_specials("", 0, "", ["10"])`
>
> #### 第 3 步：触发终点（Base Case）
>
> - 现在的参数：传入的字符串变成了 `""`。
>
> - 这次，底下的递归主体匹配不上了（因为它要求至少有一个字符 `char`）。
>
> - 于是它匹配到了写在最上面的**递归终点**：
>
>   `defp split_specials("", _count, _current, acc), do: Enum.reverse(acc)`
>
> - 此时 `acc` 是 `["10"]`，反转之后依然是 `["10"]`。



为什么这种写法叫“尾递归”？它为什么不爆内存？

在常规的递归里（比如算斐波那契数列 `fib(n) = fib(n-1) + fib(n-2)`），函数调用完自己之后，**还有别的计算要做**（比如加法）。这意味着计算机必须把当前函数的状态保存在内存（调用栈）里，等下一层递归返回了，再接着算。如果递归深了，内存就爆了（栈溢出）。

但你仔细看我们刚才的 `split_specials`：

```Elixir
    # ... 前面算了一堆状态 ...
    if new_count == 0 do
      split_specials(...) # <-- 最后一步，只有调用自己，没有任何其他操作
    else
      split_specials(...) # <-- 最后一步，只有调用自己，没有任何其他操作
    end
```

**不管走哪个分支，这个函数的最后也是唯一的一步，就是调用自己。这就叫“尾部调用（Tail Call）”。**

当 Erlang 虚拟机 (BEAM) 看到这种写法时，它会极其聪明地说：“既然你这个函数已经没有其他事情可做了，我干嘛还要保留你的内存空间？我直接把你的内存状态替换成下一层需要的参数，然后**跳转（GOTO）**过去就行了！”

**这就是所谓的“尾递归优化 (Tail Call Optimization)”。** 在底层机器码层面，它根本没有在栈上堆叠内存，它就是在一个固定大小的内存空间里无限转圈。**这就是为什么在 Elixir 里，尾递归 = 绝对高效的 while 循环。**

> 顺带一提：为什么要 `[new_current | acc]` 然后最后 `Enum.reverse(acc)`？
>
> 你可能注意到了，当我们找到一个新子串时，我们是把它放在列表的**最前面**：`[new_current | acc]`，而不是追加到最后面。
>
> 这是因为 Elixir 的列表是**单向链表（Linked List）**：
>
> - 在链表**头部**插入一个元素，时间复杂度是 $O(1)$（极快）。
> - 在链表**尾部**追加一个元素，必须从头遍历整个链表，时间复杂度是 $O(N)$（极慢）。
>
> 所以，函数式编程的经典套路就是：**不断地把新东西高效地塞进头部（这会导致最后得到的列表是反的），等所有循环结束了，再花 $O(N)$ 的时间统一翻转一次 (`Enum.reverse`)。** 这比每次都在尾部追加要快得多！



这道题的复杂度分析也值得思考，这种做法可以得到 $O(n^2)$ 的复杂度，瓶颈似乎在于每次递归 $O(n)$ 的数组复制，而不是排序。但是，这一瓶颈是可以被优化的，参考 [hqztrue 的复杂度分析](https://leetcode.cn/problems/special-binary-string/solutions/1731760/on-log-n-by-hqztrue-nrmw/)。
