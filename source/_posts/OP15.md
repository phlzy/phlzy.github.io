---
title: 【OP15】NC-Setsuna with Sequence
date: 2022-04-05
tag: [data structure]
category: [One Problem]
math: true
---

线段树

<!--more-->


题目链接：[Setsuna with Sequence](https://ac.nowcoder.com/acm/contest/13276/K)

操作 1 可以用线段树随便维护，操作 2 则看起来不好直接处理。

我们将满足 $b[i]=1$ 的 $a[i]$ 称为“可用的”。考虑三角形边长的性质，如果不存在这样的三元组，说明对区间内可用的 $a[i]$ 升序排序后，均满足 $a[j]+a[j+1]\le a[j+2]$。显然排序后的数组每一项都不会小于斐波那契数列对应位置的值，而斐波那契数列的增长速度是非常快的，打表可以发现第 $26$ 项就已经超出值域了。因此如果可用的 $a[i]$ 数量超过 $26$，就一定有解。这个数量可以直接用线段树维护 $b[i]$ 得到。如果数量不超过 $26$，直接在线段树上暴力找，复杂度不会超过 $O(s\log n)$（$s$ 为可用的 $a[i]$ 的个数），然后排序暴力检测就好了。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int inf = 0x3f3f3f3f;
const int maxn = 1e5 + 5;
namespace sgt{
int tag[maxn << 2], cnt[maxn << 2];
void push_up(int p) {
	cnt[p] = cnt[p << 1] + cnt[p << 1 | 1];
}
void build(int p, int l, int r, int* b) {
	if (l == r) {
		tag[p] = b[l];
		cnt[p] = tag[p];
		return;
	}
	int mid = l + r >> 1;
	build(p << 1, l, mid, b);
	build(p << 1 | 1, mid + 1, r, b);
	push_up(p);
}
void push_down(int p, int l, int r) {
	if (!tag[p]) return;
	tag[p << 1] = !tag[p << 1];
	tag[p << 1 | 1] = !tag[p << 1 | 1];
	int mid = l + r >> 1;
	cnt[p << 1] = mid - l + 1 - cnt[p << 1];
	cnt[p << 1 | 1] = r - mid - cnt[p << 1 | 1];
	tag[p] = 0;
}
void modify(int p, int x, int y, int l, int r) {
	if (x <= l && r <= y) {
		tag[p] = !tag[p];
		cnt[p] = r - l + 1 - cnt[p];
		return;
	}
	push_down(p, l, r);
	int mid = l + r >> 1;
	if (x <= mid) modify(p << 1, x, y, l, mid);
	if (mid < y) modify(p << 1 | 1, x, y, mid + 1, r);
	push_up(p);
}
int query(int p, int x, int y, int l, int r) {
	if (x <= l && r <= y) {
		return cnt[p];
	}
	push_down(p, l, r);
	int mid = l + r >> 1, ans = 0;
	if (x <= mid) ans += query(p << 1, x, y, l, mid);
	if (mid < y) ans += query(p << 1 | 1, x, y, mid + 1, r);
	push_up(p);
	return ans;
}
void fuck(int p, int x, int y, int l, int r, vector<int>& v, int* a) {
	if (l == r) {
		if (tag[p]) v.push_back(a[l]);
		return;
	}
	push_down(p, l, r);
	int mid = l + r >> 1;
	if (x <= mid && cnt[p << 1]) fuck(p << 1, x, y, l, mid, v, a);
	if (mid < y && cnt[p << 1 | 1]) fuck(p << 1 | 1, x, y, mid + 1, r, v, a);
	push_up(p);
}
};
int a[maxn], b[maxn];
void solve() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)    
		cin >> a[i];
	for (int i = 1; i <= n; ++i)    
		cin >> b[i];
	sgt::build(1, 1, n, b);
	const int mx = 27; // f[26] = 121393
	while (m--) {
		int op, l, r;
		cin >> op >> l >> r;
		if (op == 1) {
			sgt::modify(1, l, r, 1, n);
		} else {
			int cnt = sgt::query(1, l, r, 1, n);
			if (cnt <= 2) {
				cout << "NO\n";
				continue;
			}
			if (cnt >= mx) {
				cout << "YES\n";
				continue;
			}
			vector<int> tmp;
			sgt::fuck(1, l, r, 1, n, tmp, a);
			sort(tmp.begin(), tmp.end());
			bool ok = 0;
			for (int i = 2; i < tmp.size(); ++i) {
				if (tmp[i - 2] + tmp[i - 1] > tmp[i]) {
					ok = 1;
					break;
				}
			}
			cout << (ok ? "YES\n" : "NO\n");
		}
	}
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

