---
title: Elixir5-并发模型
date: 2026-02-25
tag: [Elixir]
category: [Software Engineering]
math: true
---

Elixir 的并发模型

<!--more-->

# 基础概念

我已经把 C++ 和操作系统课的并发和多线程技术忘光了，所以让 AI 先生动形象的讲一讲基础知识：

## 什么是并发

假设你开了一家餐厅，你是唯一的大厨。

- **单步执行（没有并发）**：客人 A 点了一份“炖牛肉”（需要熬 2 小时）。你把牛肉放在火上，然后**你就站在锅边死死盯着**，什么都不干。2 小时后牛肉出锅，你端给 A。然后你才开始接待客人 B。—— *这家店迟早倒闭。*
- **并发执行（Concurrency）**：你把牛肉炖在火上，然后定个闹钟。在这 2 小时里，你转身去给客人 B 炒个青菜，给客人 C 倒杯水。—— *这就是并发，**同时处理多件事情的能力**。*

## 传统编程的噩梦

生意太好了，你雇了 5 个大厨（这就是操作系统里的“多线程”）。

传统语言的问题在于，它们采用的是**“共享厨房”（共享内存）**模型。

5 个大厨在一个巨大的厨房里工作，共用一把菜刀、一罐盐、一个砧板。

**会发生什么惨剧？**

1. **竞态条件（Race Condition）**：大厨 A 和大厨 B 同时伸手去拿盐罐。A 以为罐子里有盐，结果 B 提前零点几秒把盐倒光了。A 做出来的菜就没味道了。（数据错乱）
2. **死锁（Deadlock）**：为了防止大家抢菜刀，你规定“谁先拿到菜刀，别人就得等”。结果大厨 A 拿了菜刀，大厨 B 拿了砧板。A 喊：“把砧板给我！” B 喊：“把菜刀给我！” 两人互不相让，厨房彻底瘫痪。

这就是为什么学 C++/Python 的并发会让人头秃。你需要花大量精力去设计各种“锁”（互斥锁、读写锁），就为了让大厨们别打架。

## Elixir 的降维打击（Actor 模型）

Elixir（Erlang）的创造者觉得“共享厨房”简直反人类。于是他们发明了另一种模式：**Actor 模型**。

在 Elixir 的餐厅里，规矩是这样的：

1. **无限的独立小包间（进程 Process）**：

   你不仅雇了大厨，你还给每个大厨发了一个**完全独立的小厨房**。大厨 A 拥有自己的刀、自己的盐；大厨 B 也有自己的刀和盐。

   *在 Elixir 里，启动一个小厨房的成本极其低廉（几微秒），一台中等配置的电脑可以瞬间建起 200 万个小厨房。*

2. **绝对禁止串门（内存隔离）**：

   大厨 A 绝对不可以走进大厨 B 的厨房去拿东西。门都没有！既然大家不抢东西，**根本就不需要“锁”这种东西了。**

3. **唯一沟通方式：塞纸条（消息传递）**：

   如果大厨 A 需要大厨 B 帮忙切个洋葱怎么办？

   大厨 A 只能写一张纸条：“帮我切个洋葱，切好给我”。然后把纸条塞进大厨 B 门外的**信箱（Mailbox）**里。

   大厨 B 在自己的厨房里忙完手头的事，打开信箱，看到纸条，切好洋葱，再写张纸条包着洋葱，塞回 A 的信箱。

# 回到 Elixir

1. **`spawn` (建厨房 & 雇大厨)**：

   只要你调用 `spawn`，Elixir 就会瞬间建好一个独立小厨房，安排一个大厨进去执行你指定的任务。它会返回一个邮箱地址（PID）。

   

   ```Elixir
   # 建个厨房，让大厨在里面等信件
   pid = spawn(fn -> 大厨的工作逻辑() end) 
   ```

2. **`send` (往信箱里塞纸条)**：

   你想让某个小厨房干活，你就根据它的地址（PID）给它发消息。塞完纸条你就去干别的，不用傻等。

   

   ```Elixir
   # 往 pid 那个厨房的信箱里塞一张纸条，内容是 {:切菜, "洋葱"}
   send(pid, {:切菜, "洋葱"})
   ```

3. **`receive` (大厨看信箱)**：

   大厨在小厨房里干活时，用 `receive` 来检查自己的信箱。

   

   ```Elixir
   # 大厨的逻辑：
   receive do
     {:切菜, 蔬菜名} -> 
       IO.puts("好的，我正在切 #{蔬菜名}")
     {:休息} -> 
       IO.puts("我下班了！")
   end
   ```



> 没有共享，就没有伤害。Elixir 的并发之所以简单，是因为每个“进程”（小厨房）都是自给自足的，它们只能通过互相发纸条（消息）来协作。你永远不需要考虑“如果两个人同时修改一个变量怎么办”，因为在 Elixir 里，这在物理层面上就是不可能发生的。



## BEAM 进程

在 Elixir 中，我们不叫“线程”，我们叫**进程（Process）**。

**严重警告：这绝对不是你操作系统课上学的 OS 进程或 OS 线程！**

- **OS 线程（C++/Python）：** 由操作系统内核调度，切换代价极高，每个线程需要几 MB 的内存。一台普通电脑开几千个线程就卡死了。
- **BEAM 进程（Elixir）：** 由 Elixir 的虚拟机（BEAM）自己调度。它极其轻量，**创建一个只要 1 到 2 KB 的内存，几微秒就能启动**。
- **结论：** 在 Elixir 里，一台普通的服务器同时跑 **200 万个** 进程是常规操作。

## Actor 模型的“三大铁律”

Actor 模型是一种并发设计模式。在 Elixir 里，每个“进程”就是一个独立运作的 Actor。它们必须遵守以下三条铁律：

1. **绝对的内存隔离：** 进程 A 绝对不可能直接读取或修改进程 B 的变量。没有共享内存，**自然就不需要任何锁（Mutex）**！
2. **唯一的交流方式是发消息：** 如果进程 A 想让进程 B 做点事，或者拿进程 B 的数据，A 只能给 B 发送一条消息（Message）。
3. **每个进程都有一个“邮箱”（Mailbox）：** 发送的消息会排队进入接收者的邮箱。接收者按照自己的节奏，一条一条地从邮箱里拿出消息来处理。

> **比喻：** C++ 的多线程就像几个人抢着在同一块黑板（共享内存）上写字，必须用一把戒尺（锁）来维持秩序；
>
> Elixir 的进程就像几个坐在独立办公室里的人，他们只能通过互相寄信（发消息）来沟通工作。

## `spawn`, `send`, `receive`

这是 Elixir 并发编程的三个核心关键字。我们来创建一个“复读机”进程。



```Elixir
# 1. 定义一个可以在独立进程中运行的函数
defmodule Parrot do
  def listen do
    # receive 块：打开进程的邮箱，查看有没有信件
    receive do
      # 利用我们之前学的【模式匹配】来处理不同的消息
      {:say, msg} -> 
        IO.puts("复读机说: #{msg}")
        listen() # 尾递归：处理完一条消息，继续监听下一条
        
      :sleep ->
        IO.puts("复读机去睡觉了...")
        # 没有调用 listen()，进程执行结束，安静地死亡并释放内存
        
      _ ->
        IO.puts("听不懂你在说什么")
        listen()
    end
  end
end

# ----------------- 下面是主进程的操作 -----------------

# 2. 孵化 (Spawn) 一个新进程！
# 这个 pid (Process ID) 就是新进程的“邮寄地址”
pid = spawn(fn -> Parrot.listen() end)

# 3. 主进程给复读机发送消息 (发完立刻不管，非阻塞)
send(pid, {:say, "Hello Elixir!"})
send(pid, {:say, "并发真好玩"})
send(pid, :sleep)

# 输出结果：
# 复读机说: Hello Elixir!
# 复读机说: 并发真好玩
# 复读机去睡觉了...
```

简单解释：

- **`spawn`**：在虚拟机的另一个角落瞬间开辟一块极小的内存，跑起传入的函数。它会返回一个 `PID`（类似进程的身份证号）。
- **`send(pid, message)`**：把数据（通常是元组或原子）塞进目标进程的邮箱。这个操作是异步的，发送者发完就继续干自己的事，不用等。
- **`receive do ... end`**：进程自己去邮箱里拿信，配合**模式匹配**决定怎么处理。如果邮箱是空的，进程就会休眠（不占 CPU），直到新消息到来。

### 这种设计的好处

1. **没有 Race Condition**：因为内存不共享，你永远不用担心变量被别人偷偷改掉。
2. **极度解耦，天然分布式**：`send(pid, msg)` 这个函数太牛了。如果这个 `pid` 是一台在纽约的服务器上的进程，而你在这段代码跑在东京的服务器上，**代码写法完全一样**！BEAM 虚拟机会自动帮你把消息打包通过 TCP 发送过去。
3. **“任其崩溃” (Let it crash)**：在 C++ 里，一个线程抛出未捕获的异常（比如段错误），整个系统进程直接崩溃重启。在 Elixir 里，如果这个“复读机”进程因为处理错误数据崩溃了，**只会死它自己一个**，其他几百万个进程依然在欢快地跑着。

### 死锁

在 Elixir（或者任何基于消息传递的系统）中，虽然没有抢夺共享资源的“互斥锁死锁（Mutex Deadlock）”，但仍然会发生**“逻辑死锁（Logical Deadlock）”**，或者叫**“互相等待（Deadly Embrace）”**。

延续之前的餐厅厨房比喻：

> 假设大厨 A 正在做“番茄炒蛋”，大厨 B 正在做“紫菜蛋花汤”。
>
> 1. 大厨 A 发现没有盐了，于是给 B 塞纸条：“把你的盐给我，**我在这里停下手头所有的活儿，死等你的盐（进入 `receive` 阻塞状态）**”。
> 2. 极其凑巧的是，在同一微秒，大厨 B 发现没有鸡蛋了，于是给 A 塞纸条：“把你的鸡蛋给我，**我也停下手头的活儿，死等你的鸡蛋（进入 `receive` 阻塞状态）**”。
>
> **结果：** A 在等 B 的回信，B 在等 A 的回信。两个小厨房彻底停工，永远等下去。这就是 Actor 模型下的死锁。

如何解决这个问题？

#### Timeouts 超时机制

Elixir 的缔造者早就想到了这个问题，所以他们在 `receive` 语法里内置了一个绝对的杀手锏：**`after`（超时设定）**。

在真实的业务代码里，我们**永远不允许“死等”**。大厨 A 在等信件的时候，一定会定个闹钟（比如 5 秒）：

```Elixir
# 大厨 A 的逻辑
send(chef_b_pid, {:借东西, "盐", self()}) # self() 是自己的地址，方便对方回信

receive do
  {:给你, "盐"} -> 
    IO.puts("拿到盐了，继续炒菜！")
    
after
  5000 -> 
    # 核心救命机制！如果 5000 毫秒（5秒）后信箱里还没有这封信
    # 大厨 A 会自动从死等状态醒来！
    IO.puts("等了 5 秒还没给，不等了！这盘菜我不做了，直接扔掉（报错/重试）！")
end
```

有了 `after`，**永久性的死锁在 Elixir 中被物理消灭了**。最坏的情况也只是卡顿 5 秒钟，然后进程抛出超时异常（Timeout Exception）。

#### “任其崩溃”（Let it crash）

你可能会问：大厨 A 抛出异常崩溃了，怎么办？这道菜不就毁了吗？

没关系！还记得 Elixir 是“并发之王”吗？

在 Elixir 的餐厅里，还有一个角色叫**“监工（Supervisor）”**。 如果大厨 A 因为等不到盐，气得崩溃了（进程死亡）。监工会在 1 微秒内发现，然后**瞬间原地复活一个全新的大厨 A**，让他重新开始做这道菜。这就是著名的容错机制（Fault Tolerance）。

对比 C++ / Python：

| **特性**     | **C++ / Python (共享内存)**                        | **Elixir (Actor 模型消息传递)**               |
| ------------ | -------------------------------------------------- | --------------------------------------------- |
| **死锁原因** | 两个线程互相拿着对方需要的**系统锁 (Mutex)**       | 两个进程互相在 `receive` 里**干等对方的消息** |
| **解决难度** | 极难。需要非常小心地设计加锁顺序，容易出隐蔽的 Bug | 极简。代码里加个 `after 5000` 超时就解决了    |
| **失败后果** | 一个线程死锁或崩溃，常常拖垮整个操作系统进程       | 一个 BEAM 进程崩溃，只影响它自己，瞬间被重启  |

可以看到，Elixir 并没有“消灭”所有的逻辑错误，它的哲学是：**既然错误（比如互相死等）一定会在几亿次交互中发生，那我就让“从错误中恢复”变得极其廉价。** 崩了就崩了，重启重试就好，绝不让整个系统宕机。

# 实际应用



在 C++ 或 Python 里，你想统计网站访问量，闭着眼睛就能写出来：搞一个全局变量 `int visit_count = 0;`，每次有请求来，加个互斥锁（Mutex），执行 `visit_count++`，解锁，完事。

但在 Elixir 里，**数据是不可变的（Immutable），也没有全局变量**。你连 `visit_count = visit_count + 1` 这种代码都写不出来！那到底怎么记账？

答案是：**雇一个专门记账的“数字人”（单开一个进程），让它在自己的小房间里死循环！**

## 底层：尾递归 + 邮箱

在 Elixir 中，保存状态的本质是：**利用函数的参数来记住当下的值，然后通过调用自己（递归）把新的值传给下一秒的自己。**

我们手写一个“访问量计数器”进程：

```Elixir
defmodule Counter do
  # 初始启动函数
  def start(initial_value) do
    # 孵化一个小房间，大厨（进程）带着初始值开始工作
    spawn(fn -> loop(initial_value) end)
  end

  # 核心魔法：死循环（尾递归）
  defp loop(count) do
    receive do
      # 收到 "增加" 的纸条
      {:increment} ->
        # 魔法在这里：把 count + 1 作为参数，重新调用自己！
        loop(count + 1)

      # 收到 "查看" 的纸条，并且附带了发件人的地址（caller_pid）
      {:get, caller_pid} ->
        # 把当前的值写在纸条上，塞回给发件人
        send(caller_pid, {:count_is, count})
        # 状态没变，用原来的 count 继续调用自己
        loop(count)
    end
  end
end
```

**怎么使用它？**

```Elixir
# 1. 启动计数器，初始值为 0
counter_pid = Counter.start(0)

# 2. 模拟 3 次网站访问（任何人都可以往它的信箱塞纸条）
send(counter_pid, {:increment})
send(counter_pid, {:increment})
send(counter_pid, {:increment})

# 3. 我想看看现在的访问量
send(counter_pid, {:get, self()}) # self() 是当前终端的地址

# 4. 去我的信箱里拿结果
receive do
  {:count_is, current_count} -> 
    IO.puts("当前网站总访问量是: #{current_count}") # 输出 3
end
```

## 标准实现：Agent 与 GenServer

上面手写 `receive` 循环虽然精妙，但在真实的工业界，手写的循环没有处理超时、没有处理系统重启、没法优雅关闭。因此，Elixir/Erlang 官方提供了一套工业级标准封装。最简单的一个叫 **`Agent`（特工）**，最复杂强大的叫 **`GenServer`（通用服务器）**。

### 用 `Agent` 实现计数器

`Agent` 专门用来在内存中保存简单的状态。它底层就是刚才那个死循环，但被包装得极其好用：

```Elixir
# 1. 启动一个 Agent 进程，初始状态设为 0（传一个匿名函数进去返回初始值）
{:ok, counter_pid} = Agent.start_link(fn -> 0 end)

# 2. 修改状态：告诉 Agent，把里面的数字拿出来 + 1，放回去
Agent.update(counter_pid, fn current_state -> current_state + 1 end)
Agent.update(counter_pid, fn current_state -> current_state + 1 end)

# 3. 读取状态：告诉 Agent，把你里面的数字给我看看
result = Agent.get(counter_pid, fn current_state -> current_state end)

IO.puts("Agent 计数器的值是: #{result}") # 输出 2
```



你不需要写 `receive`，不需要写递归。你只需要把**“你想怎么修改数据”的逻辑（匿名函数）**丢给 `Agent`，那个专门负责记账的进程就会在它的小房间里帮你执行，并把结果存下来。

## 总结

在 C++/Python 中，你维护一个全局的字典或计数器，然后防贼一样防着多线程同时修改它。

在 Elixir 中，**你把数据锁在一个独立的进程（小房间）里，任何人想读写数据，只能在门外排队塞纸条。** 房间里的进程一次只处理一张纸条，**天生就是串行且线程安全的**！

这不仅仅能存计数器，你在 Elixir 里做：

- 内存缓存（Cache）
- 购物车数据
- 游戏房间里的玩家状态

全部都是通过这种“单开一个进程循环保存状态”的模式实现的。

