---
title: CPP5-STL基础
date: 2026-02-26
tag: [cpp]
category: [Software Engineering]
math: true
---

简单复习一下 STL

<!--more-->

针对 STL，考虑性能损耗、内存分配机制以及 CPU 缓存友好度。

我们直接跳过基础用法，深入现代 C++ 工程中最核心的 STL 考点。

## 最常用容器：vector

`vector` 是 C++ 工业界使用频率最高的容器，没有之一。哪怕有时理论上该用链表（`std::list`），工程界也倾向于用 `vector`。

### 核心机制：Size vs Capacity

- **Size:** 当前存了多少个元素。

- **Capacity:** 当前分配的底层内存最多能存多少个元素。

  当 `Size == Capacity` 时，如果再插入元素，就会触发**动态扩容**。

### 经典问题：扩容因子是几倍？为什么？

- **GCC / Clang (Linux/macOS):** 通常是 **2 倍**扩容。
- **MSVC (Windows):** 通常是 **1.5 倍**扩容。

**深层原因（为什么 1.5 倍可能更好？）：**

这是一个非常经典的内存分配数学题。如果你每次扩容 2 倍，你的内存块大小序列是：1, 2, 4, 8, 16, 32...

当你需要分配 32 的空间时，前面释放的所有空间总和是 `1+2+4+8+16 = 31`。**前面释放的内存碎片总和，永远小于下一次需要的空间！** 这意味着底层的内存分配器（Allocator）永远无法复用之前释放的内存块，只能不断向操作系统申请新的内存。

而如果是 1.5 倍扩容：1, 2, 3, 4, 6, 9, 13, 19... 到了后面，之前释放的内存块总和就能覆盖下一次的需求，从而**极大地提高了内存复用率**。

### 性能优化：`push_back` vs `emplace_back`

原理是**移动语义和右值引用**。

- `push_back()`: 接收一个已经构造好的对象。如果你传一个临时对象，它会先构造这个临时对象，然后调用**移动构造函数**（C++11 之后）把它塞进 `vector`，最后销毁临时对象。
- `emplace_back()`: 运用了 C++11 的**可变参数模板 (Variadic Templates)** 和 **完美转发 (Perfect Forwarding)**。它直接把你传入的构造参数转发到底层的内存中，**在 vector 的内存里原地直接构造对象**。

**结论：** `emplace_back` 省去了一次移动构造和一次析构，开销逼近理论极限的 0。在现代 C++ 中，尽量用 `emplace_back` 替代 `push_back`。

## 节点型容器的痛点：CPU 缓存命中率 (Cache Locality)

在算法竞赛中，如果要求 $O(1)$ 查找，选 `unordered_map`；如果要求 $O(\log N)$ 有序查找，选 `map`。

但在工业界极致追求性能的代码中，它们往往不是首选，因为 CPU Cache 不喜欢它们：

- `std::vector` 的内存在物理上是**绝对连续**的。当 CPU 读取 `vector[0]` 时，由于“空间局部性原理”，它会把 `vector[1]` 到 `vector[7]`（假设一个 Cache Line 是 64 字节）全部一次性预载入极其高速的 L1 Cache 中。后续的遍历速度很快。
- `std::map` (红黑树) 和 `std::list` (双向链表) 每次插入新节点，都是在堆上随机 `new` 出一块内存。这些节点在物理内存中是分散的。
- 当你遍历 `map` 或 `list` 时，CPU 每跳到一个节点，大概率都会遭遇 **Cache Miss（缓存未命中）**，被迫去缓慢的主存（RAM）里捞数据。一次 Cache Miss 的时间损耗，足以让 CPU 执行几百条普通指令！

**工业界最佳实践：**

在数据量不大（比如几百个元素以内）时，**一个保持排序的 `std::vector` + 二分查找 (`std::binary_search`)，其真实运行速度往往碾压 `std::map` 甚至 `std::unordered_map`！** 

### 哈希冲突

虽然底层的确是哈希表，但 C++ 标准库的 `unordered_map` 通常采用的是 **拉链法 (Chaining)** 来解决哈希冲突，也就是数组 + 链表（或桶）。

这也意味着，它内部实际上也是由一堆零散的指针连接起来的，同样存在严重的 Cache Miss 问题。

*(注：Google 开源的 `absl::flat_hash_map` 采用了开放寻址法，将所有数据拍平在一个连续数组里，是目前 C++ 工业界公认性能最强的哈希表之一。)*



## 经典问题


### 关于迭代器失效 Iterator Invalidation

假设我有一个 `std::vector<int> v = {1, 2, 3, 4, 5}`，我用一个指针 `int* p = &v[2];` 指向数字 3。接着，我执行了 `v.push_back(6);`。

请问此时指针 `p` 还能安全地访问数字 3 吗？为什么？

**不一定安全**，虽然数字 3 在vector 中的位置没有发生改变，但是如果 vector 扩容导致前面的元素被复制到了另一块内存上，那么这个指针可能就失效了。

这是 C++ 工程中最臭名昭著的 **Use-After-Free (UAF)** 漏洞来源之一。**一定要注意内存生命周期**。对于 `vector`，只要发生了扩容（Capacity 改变），所有指向它的迭代器、指针、引用将**全部瞬间失效**。如果没有发生扩容，插入点之后的迭代器会失效（因为元素被往后挪了），但插入点之前的依然有效。

### 关于 `emplace_back` 的陷阱

我们说 `emplace_back` 可以原地构造，避免拷贝/移动。但假设一个类的构造函数非常耗时，我连续执行了 100 次 `v.emplace_back(...)`。在这个过程中，真的**完全没有**发生过拷贝或移动吗？

> 这是非常关键的异常安全（Exception Safety）与移动语义的隐藏陷阱！

**这取决于你的对象的移动构造函数有没有加 `noexcept` 关键字！**

- **如果加了 `noexcept`：** 编译器知道移动过程绝对不会抛出异常，它就会开心地使用**移动构造**（只转移内部指针），极快地把对象“搬”到新内存，依然保持物理连续。
- **如果没有加 `noexcept`（哪怕你写了移动构造）：** 编译器为了保证**强异常安全性（Strong Exception Guarantee）**，会强制退回到**深拷贝**！为什么？因为如果移动到一半，某个对象抛出了异常，老内存已经被破坏了（资源被偷走了），新内存也没建好，程序状态就彻底损毁了。如果是深拷贝，拷贝失败了大不了把新内存扔掉，老内存还是完好无损的。

#### 为什么会这样？

当 `vector` 扩容时，它确实会开辟一块全新的、更大的**连续内存**。但接下来，把老数据转移到新内存时，是**拷贝**还是**移动**呢？

首先，移动是如何做到的？既然 `vector` 里的内存是连续的，元素是一个挨着一个的真真正正的**对象实例**（而不是指针），那扩容的时候，不管你怎么 move，不还是得把这些对象所占的字节从老内存一点点拷到新内存吗？为什么这可以移动？

简而言之：**在连续内存中，Move 转移的不是对象所占的物理空间（躯壳必须复制），而是对象内部指针所掌管的外部堆资源。**

#### Trivial Types / POD（Plain Old Data）

假设你的 vector 长这样：`std::vector<int>` 或者 `std::vector<Point>`（其中 `struct Point { int x; int y; };`）。

对于这种对象，它没有在堆上申请任何动态内存，它所有的身家性命都在自己这几个字节里。

- **在这里，Move（移动） == Copy（拷贝）。**
- 扩容时，编译器会老老实实地把旧内存里的 `Point` 的 8 个字节，一模一样地复制到新内存里。没有任何取巧的余地。这种情况下，移动语义**没有任何性能加速**。

#### Resource-Owning Types

这就是移动语义真正大显神威的地方。最典型的就是 `std::string` 或者 `std::vector<std::vector<int>>`。

我们拿 `std::vector<std::string>` 举例。一个 `std::string` 对象在栈上（或者 vector 的连续内存里）到底长什么样？

通常，它只占 24 个字节（在 64 位系统下），被称为**“控制块 / 躯壳”**：

1. `char* data;` （指向堆上一大段字符串的指针，8字节）
2. `size_t size;` （字符串长度，8字节）
3. `size_t capacity;` （堆内存容量，8字节）

假设你的 `string` 里存了一篇 10MB 的文章。这 10MB 是存在**离散的堆（Heap）**上的，而在这块 `vector` 的连续内存里，仅仅只存了那 24 个字节的“躯壳”。

**现在，`vector` 扩容了，发生 Move 的时候，物理层面到底发生了什么？**

1. `vector` 申请了一块新的连续内存，用来放这些 24 字节的躯壳。
2. 调用 `string` 的**移动构造函数**。
3. **极速搬运：** 把旧躯壳的 24 字节（那个指向 10MB 堆内存的指针、size、capacity）**直接复制**到新躯壳里。
4. **掏空原主：** 把旧躯壳里的 `data` 指针设为 `nullptr`，`size` 设为 0。
5. **极其核心的结论：那篇 10MB 的文章在堆上纹丝不动！**

你看，虽然我们依然发生了物理上的内存复制（复制了 24 个字节的躯壳），但我们**避免了深拷贝那 10MB 的堆内存**！这就是移动构造之所以快的原因：它转移的是**资产的所有权（指针）**，而不是资产本身。

#### 重新审视 `noexcept` 的坑

顺着上面的底层原理，假设在扩容搬运到一半时（比如搬了 5 个 string 的躯壳），第 6 个 string 的移动构造函数突然抛出了异常。

- 此时，前 5 个旧躯壳的指针已经被置为 `nullptr` 了！它们持有的 10MB 文章所有权已经“偷”给新内存了。
- 如果此时因为异常要中断扩容、销毁新内存，那前 5 个被转移的文章就会跟着新内存一起被析构掉（销毁），而旧 vector 里前 5 个元素变成了空字符串，数据**永久丢失**！

这就是为什么只要你没写 `noexcept`，编译器为了保证**强异常安全性（绝对不弄坏旧数据）**，打死也不敢用移动构造。它宁愿去老老实实地重新开辟 10MB 内存做深拷贝。因为深拷贝如果失败了，大不了把新申请的一半内存扔了，旧 vector 里的指针依然完好无损地指着原来的文章。

**注意：** 自定义类的移动构造函数和移动赋值运算符，**永远记得加上 `noexcept`**！否则 `std::vector` 扩容时会让你付出极其惨痛的性能代价。

### 关于自定义 Key

在做算法题时，我们经常用 `std::pair<int, int>` 作为 `std::map` 的键（Key）。

如果我想用 `std::pair<int, int>` 或者自定义的 `struct Point { int x, int y; }` 作为 **`std::unordered_map`** 的键，编译器会直接报错。这是为什么？需要我手动提供什么机制才能让它编译通过？

1. 因为没有内置的哈希函数，需要自己提供一个。
2. 还需要一个判等函数 (`operator==`)，因为哈希一定会发生冲突（碰撞），当两个不同的 Point 算出了相同的 Hash 值被放进同一个桶（链表）时，哈希表需要用 `==` 挨个比较它们到底是不是同一个对象。



## 一些更底层的概念

### 空间配置器 (`std::allocator`)

当你写 `std::vector<int> v;` 时，它的完整类型其实是 `std::vector<int, std::allocator<int>>`。

在算法竞赛中，你 `new` 一个对象，实际上干了两件事：1. 找操作系统要内存。2. 在内存上调用构造函数。

但在 STL 中，这两步是**严格分离**的。为什么？

如果 `vector` 预分配了 1000 的 Capacity，但 Size 只有 10，它绝对不能调用后 990 个对象的构造函数！

- `allocator::allocate(n)`：只负责在堆上切出一块未初始化的裸内存（底层类似 `malloc`）。
- **Placement New (定位 new)：** 当你 `push_back` 时，STL 会在这块已经分配好的裸内存的指定地址上，直接原地呼叫构造函数。语法长这样：`new (&memory_address) Object(args...);`。
- **工业界应用：** 游戏引擎和高频交易公司通常会重写 Allocator（比如使用内存池 Memory Pool），彻底接管 STL 的内存分配，消除向操作系统申请内存的开销。

### 迭代器萃取 (`std::iterator_traits`) 与算法分发

你肯定用过 `std::sort(v.begin(), v.end())`。但如果你写 `std::sort(list.begin(), list.end())`，编译器会直接报错，打印出几百行乱码。

为什么？因为 `std::sort` 要求的是**随机访问迭代器 (Random Access Iterator)**，你可以直接 `it + 5`。而 `std::list` 是链表，只能 `it++` 或 `it--`（双向迭代器）。

- **STL 的魔法：** 算法内部如何知道传进来的是什么迭代器？通过 `std::iterator_traits<It>::iterator_category`。
- 编译器会在**编译期**根据迭代器的种类，自动选择最高效的算法版本。这就是 C++ 的**泛型编程（Generic Programming）**思维。

### Erase-Remove Idiom

最开始接触容器的时候，我们就知道不要一边迭代一边删除：假设你有一个 `vector<int> v = {1, 2, 3, 2, 4};`，你想删掉里面所有的 `2`。如果你写一个 `for` 循环，遇到 `2` 就调用 `v.erase(it)`，程序大概率会崩溃或者跳过元素，因为 `erase` 会导致当前迭代器失效。于是，产生了一种看起来十分丑陋怪异的实现：

**C++98 / 11 的标准解法 (Erase-Remove Idiom)：**

```C++
// 1. std::remove 并不会真的删除元素，它只是把不等于 2 的元素往前挪，
//    并返回一个指向新的逻辑结尾的迭代器。
// 2. 然后用 vector 的 erase 方法把尾巴上的废弃数据真正删掉。
v.erase(std::remove(v.begin(), v.end(), 2), v.end());
```

**现代 C++ (C++20) 的解法：**

为了消灭这个反直觉的写法，C++20 直接提供了一个极其优雅的全局函数：

```C++
std::erase(v, 2); // 一行搞定！
// 或者带条件的：
std::erase_if(v, [](int x) { return x % 2 == 0; }); // 删掉所有偶数
```



