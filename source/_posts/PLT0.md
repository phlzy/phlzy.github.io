---
title: PLT0-大纲
date: 2026-02-28
tag: [PLT]
category: [Computer Science]
math: true
---

业余 Programming Language Theory (PLT) 学习大纲

<!--more-->

之前学了一点的编译原理和计算理论也早就忘光了，开一个专栏重新梳理一下。


## 第一阶段：代码是如何被机器理解的？

在进入高深的类型理论之前，我们要先统一“世界观”。语言长什么样不重要，重要的是它在内存里是什么结构。

- **第 1 篇：别被语法糖骗了——从文本到抽象语法树（AST）**
  - **核心概念**：探讨代码本质上是一棵树。
  - **现实应用**：为什么算子开发中，无论是 PyTorch 代码还是 C++ 代码，最终都要转化成统一的计算图（本质就是带有特定算子的 AST）。
- **第 2 篇：表达式（Expression）与语句（Statement）的世纪之争**
  - **核心概念**：为什么在 C++ 里 `if` 是语句（不能赋值给变量），但在 Python 或 Elixir 里 `if` 是表达式（有返回值）？
  - **思考**：纯函数式语言为什么只有表达式？这对避免代码副作用有什么帮助？
- **第 3 篇：变量到底存哪了？——环境（Environment）与作用域模型**
  - **核心概念**：词法作用域（Lexical Scoping）与动态作用域（Dynamic Scoping）。
  - **揭秘**：闭包（Closure）的底层到底是怎么实现的？为什么它能“记住”外层函数的变量？

## 第二阶段：函数式编程与计算的本源

理解现代高阶编程的钥匙，学习函数式编程的基础。

- **第 4 篇：比图灵机更优雅的计算本源——$\lambda$ 演算（Lambda Calculus）**
  - **核心概念**：如果世界上没有任何基本数据类型（没有数字、没有布尔值），只有一个只能接受一个参数的匿名函数，你能构建出整个计算机宇宙吗？
  - **大开眼界**：展示如何用纯函数推导出“True/False”和“自然数”（丘奇数 Church Numerals）。
  - 与 TCS 的联系：Church-Turing Thesis，Turing Complete，从自动机到图灵机，Computability Theory。
- **第 5 篇：当函数成为一等公民——高阶函数与柯里化（Currying）**
  - **核心概念**：`map`, `reduce`, `filter` 的本质。
  - **探讨**：为什么 Haskell 里所有函数默认只接受一个参数？这和算子开发有什么关系？（提示：张量计算中的 Map/Reduce 算子映射）。

## 第三阶段：类型系统，建立绝对领域的契约

类型系统是写任何代码都需要考虑的问题。

- **第 6 篇：强弱与动静——C++ 与 Python 的血泪史**
  - **实际应用**：隐式转换的灾难。
- **第 7 篇：消灭 Null 的恐惧——代数数据类型（ADT）与模式匹配**
  - **核心概念**：和类型（Sum Type）与乘积类型（Product Type）。
  - **实践**：对比 C++ 的 `union`/`std::variant` 和 OCaml/Rust 里的完美 `enum`。
- **第 8 篇：编译器如何做阅读理解？——类型推导系统（Hindley-Milner）初探**
  - **核心概念**：为什么 OCaml 不用写类型声明也能做到 100% 静态安全？图论和联合查找算法在类型推导中的应用。

## 第四阶段：打破线性执行的魔法

理解控制权是如何在程序中跳跃的。

- **第 9 篇：不要现在，要未来——严格求值与惰性求值（Lazy Evaluation）**
  - **思考**：如果定一个无限大的数组会怎样？Thunk 是什么技术？
- **第 10 篇：时空穿梭机——延续（Continuation）与 CPS 变换**
  - **核心概念**：剥开 `async/await` 和协程的底层外衣。
  - **拓展**：异常处理（`try/catch`）在底层其实也是一种特殊的延续跳转。

## 第五阶段：PLT 与算子/编译器

把 PLT 理论映射到日常工作中。

- **第 11 篇：领域特定语言（DSL）与元编程**
  - **核心概念**：同像性（Homoiconicity）与宏（Macro）。代码生成代码的艺术。
- **第 12 篇：万物皆 IR——从 AST 到中间表示**
  - **结合主业**：探索 LLVM IR 或者 MLIR。
  - **总结**：算子开发中的图优化（Graph Optimization），本质上就是在特定方言的 IR 上，做模式匹配（Pattern Matching）和代数重写（Algebraic Rewriting）。

