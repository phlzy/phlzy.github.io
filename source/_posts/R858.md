---
title: Codeforces Round 858 (Div. 2)
date: 2023-03-19
tag: [codeforces]
category: [Competitive Programming]
math: true
---

[Codeforces Round 858 (Div. 2)](https://codeforces.com/contest/1806)

这场的题出的稍微有点奇怪，但质量还是很不错的。

# A

让 $y$ 增加的方式是唯一的，所以如果能到达，两种操作的数量是唯一确定的。

# B

观察一下样例基本上就能找到规律了。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pb push_back
#define endl '\n'
using ll = long long;
using pii = pair<int, int>;
const int maxn = 5e5 + 5;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    vector<int> cnt(3, 0);
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (auto i : a) {
        if (i > 1) cnt[2]++;
        else cnt[i]++;
    }
    if (cnt[0] <= (n + 1) / 2) {
        cout << 0 << endl;
    } else if (cnt[2] > 0) {
        cout << 1 << endl;
    } else if (cnt[0] == n) {
        cout << 1 << endl;
    } else {
        cout << 2 << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }
}
```

# C

[官方题解](https://codeforces.com/blog/entry/114048)有详细的推导，这个问题在[数学竞赛](https://artofproblemsolving.com/community/c6h1262189p6556895)中也出现过。

推导的过程和上面一样，所以就不写了。最后一组样例给的很好，直接否定了 $n$ 比较大时所有数全为零的猜想。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pb push_back
#define endl '\n'
using ll = long long;
using pii = pair<int, int>;
const int maxn = 5e5 + 5;

void solve() {
    int n;
    cin >> n;
    int m = n * 2;
    vector<ll> a(m);
    for (int i = 0; i < m; ++i) {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    ll ans = 0;
    for (auto i : a)
        ans += abs(i);
    if (n == 1) {
        cout << abs(a[0] - a[1]) << endl;
    } else if (n == 2) {
        ll tmp1 = 0;
        for (int i = 0; i < m; ++i) {
            tmp1 += abs(a[i] - 2);
        }
        ans = min(ans, tmp1);
        ll tmp = 0;
        for (int i = 0; i + 1 < m; ++i) {
            tmp += abs(a[i] + 1);
        }
        tmp += abs(a[m - 1] - n);
        ans = min(ans, tmp);
        cout << ans << endl;
    } else if (n % 2 == 0) {
        ll tmp = 0;
        for (int i = 0; i + 1 < m; ++i) {
            tmp += abs(a[i] + 1);
        }
        tmp += abs(a[m - 1] - n);
        ans = min(ans, tmp);
        cout << ans << endl;
    } else {
        cout << ans << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }
}
```

# D








# E

读完题就想到了应该是 $O(n\sqrt{n})$ 的做法，但还是写错了。下面是官方题解的做法。

显然要在查询的时候把经过的某些点对的答案存起来。假设第 $i$ 层有 $s_i$ 个节点，因此最多有 $s_i^2$ 种点对。而至多进行 $n$ 次询问，因此第 $i$ 层经过的点对数量为 $\min(s_i^2, n)$。当 $s_i=\sqrt{n}$ 时，总数达到最大值 $n\sqrt{n}$。

所以直接记忆化就行了。并且对于 $s_i\gt \sqrt{n}$ 的层，可以不去记录，因为这样的层数不会超过 $\sqrt{n}$，因此至多向上跳这么多次就又到记忆化的层数了，这对总复杂度不会产生影响。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pb push_back
#define endl '\n'
using ll = long long;
using pii = pair<int, int>;
const int maxn = 1e5 + 5;
ll a[maxn];
vector<int> g[maxn];
ll sum[maxn];
int dep[maxn], fa[maxn];
int h[maxn], cnt[maxn];
const int S = 325;
ll f[maxn][S];
void dfs(int u, int f) {
    dep[u] = dep[f] + 1;
    sum[u] = sum[f] + a[u] * a[u];
    h[u] = ++cnt[dep[u]];
    for (auto v : g[u]) {
        dfs(v, u);
    }
}
ll ask(int x, int y) {
    if (x == y) {
        return sum[x];
    }
    if (cnt[dep[y]] <= S && f[x][h[y]]) {
        return f[x][h[y]];
    }
    ll ans = ask(fa[x], fa[y]) + a[x] * a[y];
    if (cnt[dep[y]] <= S) {
        f[x][h[y]] = ans;
    }
    return ans;
}
void solve() {
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 2; i <= n; ++i) {
        cin >> fa[i];
        g[fa[i]].pb(i);
    }
    dfs(1, 0);
    for (int T = 1, x, y; T <= q; ++T) {
        cin >> x >> y;
        cout << ask(x, y) << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    while (T--) {
        solve();
    }
}
```

