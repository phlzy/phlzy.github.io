---
title: Elixir6-并发进阶
date: 2026-02-26
tag: [Elixir]
category: [Software Engineering]
math: true
---

Elixir 的Link / Monitor：与其到处 try-catch，不如监督重启

<!--more-->

重点：

- `Process.link/1` 与失败传播
- `Process.monitor/1` 得到 `:DOWN` 消息

# 感性认识

我们继续用极其通俗的比喻来拆解这两个概念。忘掉代码，我们先看“关系”。

在 Elixir 的进程世界里，如果你启动了多个进程（小房间里的大厨），它们默认是**完全不认识、互不关心的**。一个大厨把厨房炸了（进程崩溃），其他大厨根本不知道，还在低头切菜。

但这在真实的系统里是不行的。比如，大厨 A 专门负责切菜，大厨 B 专门负责炒菜。A 炸了，B 还在等菜，这就僵死了。我们需要让进程之间产生“羁绊”。

这就是 **Link** 和 **Monitor** 的作用。

## Link (链接) —— “同生共死”

**比喻：** 两个攀岩者，腰间拴着同一根安全绳。

- **方向：** **双向的（Bidirectional）**。A 链接了 B，就等于 B 链接了 A。
- **规则：** 如果其中一个人脚滑掉下去了（进程异常崩溃），安全绳会瞬间把另一个人也拽下去（另一个进程也跟着崩溃）。
- **使用场景：** “咱们俩是一根绳上的蚂蚱，你死了我活着也没意义，干脆一起死，然后让别人把咱们俩同时复活。”



```Elixir
defmodule Climber do
  def start do
    # spawn_link 是一步到位的操作：建一个小房间，并且立刻和当前主进程拴上绳子
    spawn_link(fn -> 
      IO.puts("攀岩者 B 开始攀岩...")
      Process.sleep(2000)
      # 故意制造一个崩溃（比如除以零）
      1 / 0 
    end)
  end
end

IO.puts("主进程 A 开始...")
Climber.start()
IO.puts("主进程 A 正在愉快地喝茶...")

# 运行结果：
# 主进程 A 开始...
# 攀岩者 B 开始攀岩...
# 主进程 A 正在愉快地喝茶...
# (两秒后)
# ** (ArithmeticError) bad argument in arithmetic expression
# 整个程序直接退出！因为 B 死了，绳子把主进程 A 也拉死了。
```

### 失败传播（Failure Propagation）

Elixir / Erlang 并发模型（Actor 模型）的绝对核心，也是大名鼎鼎的“任其崩溃（Let it crash）”哲学的基石。

####  默认状态：孤独的进程

在 Elixir 中，使用 `spawn/1` 创建的进程默认是**完全孤立**的。

如果进程 A 孵化（spawn）了进程 B，当进程 B 因为除以零或者模式匹配失败而崩溃时，进程 A 根本不会察觉，依然会开开心心地继续运行。这种隔离性很好，但也意味着我们很难管理和回收出问题的子任务。

#### `Process.link/1`：绑定生命线

当你调用 `Process.link(pid)` 时，当前进程和目标 `pid` 进程之间就建立了一条**双向的绑定关系**（生命线）。

- **双向性：** 无论是 A 链接了 B，还是 B 链接了 A，结果是一样的。它们成了“一根绳上的蚂蚱”。
- **快捷方式：** 通常我们会在创建进程的同时直接建立链接，也就是使用 `spawn_link/1` 或 `spawn_link/3` 函数，这能防止在“创建进程”和“建立链接”的间隙发生崩溃（竞态条件）。

#### Failure Propagation

一旦两个进程被 link 起来，它们就会开始互相监听对方的“遗言”（退出信号 Exit Signal）。失败传播的规则取决于进程退出的**原因（Reason）**：

- **正常退出 (`:normal`)：** 如果进程 B 正常执行完了所有的代码，它会发出一个原因为 `:normal` 的退出信号。进程 A 收到后，会默默点个赞，**什么都不会发生**，进程 A 继续存活。
- **异常崩溃（非 `:normal`）：** 如果进程 B 因为抛出异常（如 `:badarith`）被系统干掉，或者被其他进程强杀（如 `:kill`），它会向链接的进程 A 发出一个异常退出信号。进程 A 收到这个信号后，**默认也会立刻崩溃**，并把同样的崩溃原因继续传播给和 A 链接的其他进程。

这就是**失败传播（多米诺骨牌效应）**：一个节点的崩溃，会迅速顺着 link 链条放倒所有相关的进程。

#### Trapping Exits

有时候，我们希望主进程（或者管理者进程）在子进程崩溃时不要跟着死，而是要负责“收尸”并重启子进程。这就是 Elixir 监督树（Supervisor Tree）的核心原理。

要做到这一点，进程需要将自己设置为**系统进程（System Process）**，也就是开启**捕获退出（Trap Exit）**：

```Elixir
Process.flag(:trap_exit, true)
```

当开启了 `trap_exit` 的进程 A 收到被链接进程 B 的异常退出信号时，**多米诺骨牌在 A 这里停下了**。

A 不会崩溃，而是会将这个退出信号转化为一条普通的邮箱消息。你可以通过 `receive` 块把它取出来处理。后面介绍这个。

*(注：如果收到的是极其暴力的 `Process.kill(pid, :kill)` 信号，即使开启了 trap_exit，进程也依然会被强制杀掉，这是系统的绝对底线。)*



## Monitor (监控) —— “暗中观察”

**比喻：** 餐厅经理（监工）坐在办公室里，通过**单向**摄像头盯着厨房里的大厨。

- **方向：** **单向的（Unidirectional）**。A 监控 B，B 根本不知道 A 的存在。
- **规则：** 如果大厨 B 把厨房炸了（崩溃了），摄像头会给经理 A 的信箱里塞一张报警纸条：`{:DOWN, 节点信息, 崩溃原因}`。**经理 A 绝对不会受到任何伤害**，他可以喝口茶，然后决定是不是要重新招一个大厨。
- **使用场景：** “我需要知道你的死活，但我绝对不能跟你一起死。”（这就是构建高可用系统的核心！）



```Elixir
defmodule Chef do
  def work do
    IO.puts("大厨 B 正在切菜...")
    Process.sleep(2000)
    raise "切到手了，不干了！" # 抛出异常，进程崩溃
  end
end

# 主进程 A (经理) 的视角：
IO.puts("经理 A 坐在办公室...")

# 1. 孵化一个大厨 B
chef_pid = spawn(fn -> Chef.work() end)

# 2. 经理 A 装上单向摄像头，监控大厨 B
Process.monitor(chef_pid)

# 3. 经理 A 去检查自己的信箱
receive do
  # 如果大厨 B 崩溃了，虚拟机会自动发这封信给经理
  {:DOWN, _ref, :process, ^chef_pid, reason} ->
    IO.puts("经理 A 收到通知：大厨 B 挂了，原因是：#{inspect(reason)}")
    IO.puts("经理 A 稳如泰山，立刻打电话重新招人！")
end

# 运行结果：
# 经理 A 坐在办公室...
# 大厨 B 正在切菜...
# (两秒后大厨抛出异常，但主程序没崩)
# 经理 A 收到通知：大厨 B 挂了，原因是：{%RuntimeError{message: "切到手了，不干了！"}, ...}
# 经理 A 稳如泰山，立刻打电话重新招人！
```

总结对比：

| **特性**     | **Link (链接)**              | **Monitor (监控)**                         |
| ------------ | ---------------------------- | ------------------------------------------ |
| **比喻**     | 拴在一根绳上的攀岩者         | 坐镇监控室的经理                           |
| **方向**     | 双向 (A 绑 B = B 绑 A)       | 单向 (A 看 B)                              |
| **崩溃后果** | 一方崩溃，**另一方跟着死**   | 目标崩溃，观察者**安然无恙且收到一条消息** |
| **常用 API** | `spawn_link`, `Process.link` | `spawn_monitor`, `Process.monitor`         |

# 原理与应用



## Link + Trap Exit (拦截退出信号)

如果 Link 会把别人拉死，那它看起来岂不是很不安全？这就要用到之前提到的 Trap Exit **`Process.flag(:trap_exit, true)`（拦截退出信号）**。

这相当于是一件防弹衣，如果攀岩者 A 穿上了这件防弹衣，再和 B 连上 Link 的绳子。当 B 掉下去时，绳子传过来的巨大拉力（崩溃信号）打在 A 的防弹衣上，会**瞬间变成一封普通的信件**掉进 A 的邮箱里，A 毫发无损！

**这就是 Elixir 里 `Supervisor`（监工/主管）的核心底层原理：**

1. 监工进程穿上防弹衣（`trap_exit`）。
2. 监工启动几十个工人进程，并把他们全部用 `Link` 拴在自己身上。
3. 任何一个工人崩溃，都会变成一封信传给监工。
4. 监工拆开信，发现“哦，3 号工人死了”，然后监工原地再 `spawn_link` 一个新的 3 号工人。

系统就这样实现了**永远不死、自我修复**。

## 与其到处 try-catch，不如监督重启

Elixir 为什么设计这种奇怪的机制，而不用常见的 try-catch？

**简单来说：目的相似（都是为了处理错误），但在哲学和机制上，它们是完全相反的两条路。**

在 C++ 和 Python 中，`try-catch` 是一种**“防御式编程”**；而 Elixir 的 `Link + Trap Exit` 是一种**“任其崩溃（Let it crash）”**哲学。

### 发生作用的地方不同（单体 vs 分布式）

- **`try-catch`（同一个线程内）：**

  你在大厨 A 的大脑里植入了一个指令：“如果你切到手了，赶紧包扎一下（catch），假装没事，继续切菜。” 这一切都发生在大厨 A 自己身上。

- **`Link + Trap Exit`（跨进程通信）：**

  大厨 A 切到手了，**他直接当场阵亡（进程销毁）**。大厨绝对不自己包扎！而是坐在监控室穿了防弹衣的经理（另一个进程）收到了一条消息：“大厨 A 死了”。经理挥挥手，**换一个全新的大厨进去**。

> **顺带一提：** Elixir 其实也有 `try...rescue` 语法，但我们极少使用它。因为 Elixir 认为：既然出错了，这层作用域的环境可能已经被污染了，修修补补毫无意义。

### 为什么要这样设计？（Elixir 独有的 4 大优势）

Elixir/Erlang 最初是给爱立信的电信交换机设计的，要求“九个九”（99.9999999%）的永不停机。`try-catch` 根本达不到这个要求，原因如下：

#### 1. 保证“绝对干净的初始状态”（根治内存污染）

在 C++ 里，如果你在一个复杂的逻辑中抓到了一个异常，你能保证内存里的对象状态依然是正确的吗？很难。有时候带着错误的状态继续跑，会导致更可怕的连锁崩溃。

- **Elixir 的解法：** 进程极其廉价。既然你报错了，说明你的内部状态可能乱了。与其写几百行代码去尝试恢复状态，**不如直接把你杀掉，连同你的垃圾内存一起回收**。然后经理（Supervisor）按照你刚出生时那份“绝对正确”的初始配方，重新把你造出来。
- **这就像 Windows 卡住了，你选择费劲去查杀进程，还是直接“重启试试”？Elixir 把“重启”做成了微秒级的自动化操作。**

#### 2. 关注点分离（大厨只管炒菜，经理只管看病）

- 用 `try-catch` 时，大厨的代码里掺杂了一大半的错误处理逻辑：`if 没盐 ... catch 没火 ... catch 没锅 ...`，业务逻辑被严重干扰。
- 用 `Link + Trap Exit`，大厨的代码只有“快乐路径（Happy Path）”：拿菜、切菜、炒菜。极其简洁！所有处理错误的逻辑，全被剥离到了经理（Supervisor）的代码里。

#### 3. 应对“未知的恐惧”（Heisenbugs）

`catch` 最大的弱点是：**你只能抓你预料到的错误。** 如果发生了你根本没想到的底层 Bug 呢？整个系统就崩了。

Elixir 的经理不在乎你是怎么死的。不管你是除以零、网络断了、还是宇宙射线打翻了比特位，经理的逻辑永远只有一个：**收到死讯 -> 扔掉尸体 -> 换个新人。** 这种机制能奇迹般地修复 90% 的偶发性 Bug。

#### 4. 天生支持分布式系统

`try-catch` 只能在一个 CPU 的同一个内存空间里工作。

而在 Elixir 里，**Link 那根绳子是可以跨越网络的！**

大厨 A 在北京的服务器上，经理 B 在东京的服务器上。大厨 A 崩溃了，网络底层会自动把死亡信号通过 TCP 传给东京的经理 B，经理 B 可以在东京重新起一个大厨。这种容错能力，C++ 和 Python 望尘莫及。

### 总结

- **`try-catch` 的哲学：** “我要尽一切努力阻止崩溃的发生，哪怕带着伤也要跑下去。”
- **`Link + Trap Exit` 的哲学：** “崩溃是常态，不可避免。所以让崩溃变得极其廉价，让恢复变得极其迅速。**不要防御错误，拥抱死亡并瞬间重生。**”





练习：写一个 worker 随机崩溃，另一个进程监控并记录重启次数（试试看用 monitor）
