---
title: 【OP18】NC-涛酱和策策的游戏again
date: 2022-04-08
tag: [dp]
category: [One Problem]
math: true
---


状压dp

<!--more-->



题目链接：[涛酱和策策的游戏again](https://ac.nowcoder.com/acm/contest/12482/D)

状压，枚举 $m$ 这一维，压 $n$ 这一维从上一层伸过来的那些格子的位置。可以先预处理出没有障碍的情况下的可行状态，转移的时候枚举上一位伸下来和这一维伸下去的情况，如果不与障碍物冲突的情况且剩下的格子可以被横的填满就可以转移。


``` cpp
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define endl '\n'
using ll = long long;
using pii = pair<int, int>;
const int maxn = 2048;
int chk[maxn], block[20];
ll dp[12][maxn];
void solve() {
	int n, m, k;
    while (cin >> n >> m >> k) {
        if (!n || !m)
            break;
        memset(block, 0, sizeof(block));
        int tot = (1 << n);
        for (int i = 1, x, y; i <= k; ++i) {
        	cin >> x >> y;
        	block[y] |= (1 << (x - 1));
        }
        // check [|] from last row
        for (int st = 0; st < tot; ++st) {
            int cnt = 0;
            chk[st] = 1;
            for (int i = 0; i < n; ++i) {
                if (st & (1 << i)) {
                    if (cnt & 1) {
                        chk[st] = 0;
                        break;
                    }
                    cnt = 0;
                } else {
                    cnt++;
                }
            }
            if (cnt & 1)
                chk[st] = 0;
        }
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        for (int i = 1; i <= m; ++i) {
        	// last
            for (int j = 0; j < tot; ++j) {
            	// now
            	if (j & block[i]) continue;
                for (int s = 0; s < tot; ++s) {
                	int t = j | block[i];
                	if (!(t & s) && chk[t | s])
                        dp[i][s] += dp[i - 1][j];
                }
            }
        }
        cout << dp[m][0] << endl;
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}
```

