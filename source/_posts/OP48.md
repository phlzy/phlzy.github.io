---
title: 【OP48】LC-Minimum Operations to Equalize Binary String
date: 2026-02-27
tag: [bfs]
category: [One Problem]
math: true
---

BFS，数学

<!--more-->

[题目链接](https://leetcode.cn/problems/minimum-operations-to-equalize-binary-string/description/)

给一个二进制串 s，每次操作翻转 $k$ 个下标，问能否全变成 `1`，最少几次操作。

## BFS

令 $n=|s|$，显然只需统计 `0` 和 `1` 的数量，分别记为 $x$ 和 $y$，因为 $x+y=n$，第二个维度没什么用。

操作一次之后，假设翻转了 $z$ 个 0，就有 $k-z$ 个 1 被翻转，于是状态从 $x$ 变为 $x-z+k-z=x+k-2z$。

这和最短路问题类似，初始状态是 $\{x,0\}$，目标状态是 $\{0,\text{dist}\}$，最小化这个距离，那么考虑每一步的范围：

- $z\le \min(k,\,x)$ 考虑 0 的数量
- $z\ge \max(0,\,k+x-n)$ 考虑 1 的数量

这就得到了一个简单的 BFS 做法，但是复杂度 $O(n^2)$，太高了。

容易发现，BFS 的时候，每次遍历所有可能的目标状态会产生很多重复，如果用一个并查集之类的数据结构维护这个遍历的区间，把之前走过的删掉，就可以降低复杂度了。

这就需要我们搞清楚每一步的步长，因为根据 $x+k-2z$ 的这个形式，对于初始的 $x$，每次到达的新状态的奇偶性是不变的。

```c++
class Solution {
public:
    int minOperations(string s, int k) {
        int n = s.length();
        int x = 0;
        for (auto c : s) {
            x += (c == '0');
        }
        vector<int> dis(n + 1, -1);
        dis[x] = 0;
        set<int> st[2];
        for (int i = 0; i <= n; ++i) {
            st[i & 1].insert(i);
        }
        st[x & 1].erase(x);
        queue<int> q;
        q.push(x);
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            int zl = min(k, cur);
            int zr = max(0, k + cur - n);
            int l = cur + k - 2 * zl;
            int r = cur + k - 2 * zr; 
            auto& s = st[l & 1];
            auto it = s.lower_bound(l);
            while (it != s.end()) {
                if (*it > r) break;
                q.push(*it);
                dis[*it] = dis[cur] + 1;
                s.erase(it++);
            }
        }
        return dis[0];
    }
};
```

这是 $O(n\log n)$ 的标准做法。

## 数学
参考 [灵茶山艾府的题解](https://leetcode.cn/problems/minimum-operations-to-equalize-binary-string/solutions/3768129/shu-xue-zuo-fa-pythonjavacgo-by-endlessc-ol6s/)。用到的定理第一次见，记录一下。



这个做法用到了 **Gale-Ryser 定理（Gale-Ryser Theorem）**，这是图论和组合数学中的一个重要定理。它提供了一个**充要条件**，用来判断给定的两个度数序列是否可以构成一个二分图（Bipartite Graph），或者等价地说，是否可以构造出一个具有指定行和与列和的 0-1 矩阵。

这个定理由 David Gale 和 H. J. Ryser 在 1957 年独立提出。

### 定理的正式表述

设存在两个非负整数序列：

- $A = (a_1, a_2, \dots, a_m)$ 代表二分图左侧顶点集 $U$ 的度数（或矩阵的行和）。
- $B = (b_1, b_2, \dots, b_n)$ 代表二分图右侧顶点集 $V$ 的度数（或矩阵的列和）。

假设序列 $A$ 已经按**非递增顺序**排列，即 $a_1 \ge a_2 \ge \dots \ge a_m$。

**Gale-Ryser 定理指出**：存在一个二分图满足顶点度数序列分别为 $A$ 和 $B$（或存在一个 $m \times n$ 的 0-1 矩阵，其行和为 $A$，列和为 $B$），**当且仅当**满足以下两个条件：

1. **总度数相等（总边数守恒）：**
   $$
   \sum_{i=1}^m a_i = \sum_{j=1}^n b_j
   $$

   *(直观理解：二分图左边连出的边数必须等于右边接收的边数。)*

2. **受限和条件（Majorization）：**

   对于所有的 $k \in \{1, 2, \dots, m\}$，都满足：

   $$
   \sum_{i=1}^k a_i \le \sum_{j=1}^n \min(b_j, k)
   $$

   *(直观理解：左侧度数最大的前 $k$ 个顶点，它们最多能连出的边数是受限的。因为这是简单图/0-1矩阵，这 $k$ 个顶点与右侧的任意一个度数为 $b_j$ 的顶点之间最多只能有 $\min(b_j, k)$ 条边相连。)*

### 0-1 矩阵视角的等价理解

在组合数学中，这个问题常被描述为“矩阵重构”。

- 顶点集 $U$ 对应矩阵的行，$V$ 对应矩阵的列。
- 如果 $U$ 中的顶点 $i$ 与 $V$ 中的顶点 $j$ 相连，则矩阵的第 $i$ 行 $j$ 列的元素为 1，否则为 0。
- 序列 $A$ 就是每一行所有元素加起来的和（行和），序列 $B$ 就是每一列加起来的和（列和）。

### 举个例子

假设我们有两个序列：

- 左侧期望的度数 $A = (3, 2, 2, 1)$ （已经降序排列，$m=4$）
- 右侧期望的度数 $B = (2, 2, 2, 2)$ （$n=4$）

**第一步：检查总和是否相等**

$\sum A = 3 + 2 + 2 + 1 = 8$

$\sum B = 2 + 2 + 2 + 2 = 8$

总和相等，满足条件 1。

**第二步：检查受限和条件**

我们需要对 $k=1, 2, 3, 4$ 分别检查公式 $\sum_{i=1}^k a_i \le \sum_{j=1}^4 \min(b_j, k)$：

- **$k=1$**: $a_1 = 3$。

  右侧：$\sum \min(2, 1) = 1 + 1 + 1 + 1 = 4$。

  $3 \le 4$，成立。

- **$k=2$**: $a_1 + a_2 = 5$。

  右侧：$\sum \min(2, 2) = 2 + 2 + 2 + 2 = 8$。

  $5 \le 8$，成立。

- **$k=3$**: $a_1 + a_2 + a_3 = 7$。

  右侧：$\sum \min(2, 3) = 2 + 2 + 2 + 2 = 8$。

  $7 \le 8$，成立。

- **$k=4$**: $a_1 + a_2 + a_3 + a_4 = 8$。

  右侧：$\sum \min(2, 4) = 2 + 2 + 2 + 2 = 8$。

  $8 \le 8$，成立。

所有条件都满足，因此根据 Gale-Ryser 定理，必然存在这样一个二分图（或对应的 0-1 矩阵）。




这个定理是判断一般简单图度数序列的 **Erdős-Gallai 定理**在二分图领域的对应版本。





