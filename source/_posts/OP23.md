---
title: 【OP23】AT-Cards
date: 2022-04-13
tag: [dp]
category: [One Problem]
math: true
---


dp

<!--more--> 

题目链接：[Cards](https://atcoder.jp/contests/abc247/tasks/abc247_f)

如果对 $(a_i,b_i)$ 连边，容易发现最后会形成若干个环。显然总的方案数就是每个环的方案数之积，所以只需要搞清楚一个环的情况就好了。不妨从最简单的情况开始研究，如果是一个链，一条边上的两个点至少取一个，那么显然有 $dp[i]=dp[i-1]+dp[i-2]$，对应最后一个取或不取。在环上取最后一个会影响两边的点，所以有 $f[i]=dp[i-1]+dp[i-3]$，这就是一个环的方案数了。

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
using ll = long long;
const ll mod = 998244353;
const int maxn = 2e5 + 5;
int a[maxn], b[maxn];
ll f[maxn], g[maxn];
namespace dsu {
int fa[maxn], sz[maxn];
void init(int n) {
    iota(fa, fa + n + 1, 0);
    fill(sz, sz + n + 1, 1);
}
int find(int x) { 
    return fa[x] == x ? fa[x] : (fa[x] = find(fa[x])); 
}
bool merge(int x, int y) {
    x = find(x), y = find(y);
    if (x == y)
        return false;
    if (sz[x] < sz[y])
        swap(x, y);
    fa[y] = x, sz[x] += sz[y];
    return true;
}
}; // namespace dsu
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    for (int i = 1; i <= n; ++i)
        cin >> b[i];
    dsu::init(n);
    for (int i = 1; i <= n; ++i) {
        int x = dsu::find(a[i]);
        int y = dsu::find(b[i]);
        dsu::merge(x, y);
    }
    f[1] = 2, f[2] = 3, f[3] = 5;
    g[1] = 1, g[2] = 3, g[3] = 4;
    for (int i = 4; i <= n; ++i) {
        f[i] = (f[i - 1] + f[i - 2]) % mod;
        g[i] = (f[i - 1] + f[i - 3]) % mod;
    }
    ll ans = 1;
    for (int i = 1; i <= n; ++i) {
        int fa = dsu::find(i);
        if (fa == i) {
            ans = (ans * g[dsu::sz[i]]) % mod;
        }
    }
    cout << ans << endl;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```
