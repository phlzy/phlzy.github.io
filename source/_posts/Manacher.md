---
title: Manacher's Algorithm
date: 2020-10-01
tag: [string]
category: [Algorithm and DataStructure]
math: true
---

Manacher 算法一般用于解决与回文子串有关的问题。

<!-- more -->

先从一个简单的问题开始：给定字符串 $s$，其长度为 $n$，求它的最长回文子串。

容易想到一个 $O(n^2)$ 的暴力算法：枚举每个字符作为回文串的中心的情况，每次尽可能向两边扩展，这样必定可以找到所有的回文串，可以很轻松得到答案。

这种暴力做法也有一种治标不治本的优化，即二分哈希，可以在 $O(n\log n)$ 时间解决问题。下面来看 Glenn K. Manacher 在1975年提出的巧妙算法。

在实现上述暴力算法的时候，容易注意到一个事实：长度为奇数的回文串与长度为偶数的回文串是不一样的，需要分开讨论。所以下面先只考虑长度为奇数的情况。

现在我们设法对之前的暴力算法进行优化。暴力算法之所以复杂度为 $O(n^2)$，是因为它对于每个位置都独立的计算出了以该位置为中心的最长回文子串。那么如何像 KMP 等其他常见字符串算法一样，利用之前得到的信息来优化当前的流程呢？回忆字符串的 border 的概念，回文串也有类似的性质。假设有一个长度为奇数的回文串 $p$，其对称中心在 $x$ 处，左右端点为 $(x-r,x+r)$，那么显然，$\forall t \in[0,r]$，字符串 $[x-r,x-r+2t]$ 和字符串 $[x+r-2t,x+r]$ 相等。

利用这条性质就可以进行一些优化。假设之前我们找到的右端点最靠右的回文串 $q$ 是 $[l,r]$，当前计算的位置是 $i$，那么有两种可能：

- $i\le r$：此时的 $i$ 位于一个回文串的内部，找到 $i$ 在 $q$ 内的对称点 $j$（$j=l+r-i$），显然以 $j$ 为中心的最长回文子串 $p_j$ 已经被计算过了。由于 $q$ 是已知的右端点最靠右的回文串，$p_j$ 的右端点必然不超过 $r$。令 $l_j$ 为 $p_j$ 的左端点，取 $l_0=\max(l,l_j)$，那么 $p_j$ 与 $q$ 相交的长度为 $2\times(j-l_0)+1$，将这个串对称到右边，就得到了一个以 $i$ 为中心的回文串，并且该回文串的右端点 $r_i$ 不超过 $r$。若 $r_i\lt r$，说明此处的回文串已经找完了，可以开始计算下一位置；否则意味着可以继续向外延伸，那就只能暴力往后找了。

- $i\gt r$：此时右边的字符都是未知的，没有任何可以利用的信息，只能采用暴力算法进行计算。

奇数长度回文串的问题就此解决了。偶数长度的回文串也可以采用类似的方法解决，但也能用一种简便的方法：在原串的首尾以及所有两个字符的间隔出均插入一个字符集之外的字符，形成一个长度为 $2n+1$ 的新串，则原串内所有长度为偶数的回文串在新串中也变成了长度为奇数的回文串。

Manacher 算法的代码实现也并不复杂，这里以求字符串 $s$ 的最长回文子串为例：

``` cpp
string manacher(string &s){
    int n = s.length();
    vector<char> aux(2 * n + 2);
    int m = -1;
    for (auto &&c : s) {
        aux[++m] = '#';
        aux[++m] = c;
    }
    aux[++m] = '#';
    int l = 0, r = -1;
    vector<int> p(m + 1, 0);
    for (int i = 0; i <= m; ++i) {
        if (i >= r) {
            while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])
                p[i]++;
            l = i - p[i], r = i + p[i];
        } else {
            int j = l + r - i;
            p[i] = j - max(j - p[j], l);
            if (i + p[i] == r) {
                while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])
                    p[i]++;
                l = i - p[i], r = i + p[i];
            }
        }
    }
    int st = 0, len = 0;
    for (int i = 0; i <= m; ++i) {
        if (p[i] - 1 > len) {
            len = p[i] - 1;
            st = (i - p[i] + 1) / 2;
        }
    }
    return s.substr(st, len);
}
```

可能最容易出错的部分是从新串映射回原串的过程，如果下标不从 $0$ 开始就是另一种写法了。

虽然 Manacher 算法在很多情况下都会去暴力的扩展，但它的时间复杂度依然是 $O(n)$，因为每次暴力扩展都会导致 $r$ 的改变，而 $r$ 只增不减，且不会超过 $2n+1$，所以暴力扩展的次数是 $O(n)$ 的。

- 84758431

![84758431.jpg](https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg)
