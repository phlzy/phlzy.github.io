---
title: CPP-SP-1-编译模型与CMake基础
date: 2026-02-27
tag: [cpp]
category: [Software Engineering]
math: true
---

特别专题：C++ 的编译过程与CMake

<!--more-->

先来看看一个 `.cpp` 文件是怎么变成可执行程序的。

# 整体流程

预处理 (Preprocessing) -> 编译 (Compilation) -> 汇编 (Assembly) -> 链接 (Linking)。

## 预处理

**输入：** `main.cpp` **命令：** `g++ -E main.cpp -o main.i` **输出：** `main.i` (极其庞大的纯文本文件)

**工作原理：** 预处理器完全不懂 C++ 语法。它只认识 `#` 开头的指令。

- `#include`：直接去硬盘上找到对应的头文件，把里面的几千行文本死死地“复制粘贴”到当前位置。
- `#define`：把代码里所有的宏名字无脑替换成对应的值（所以宏极易引发奇怪的 Bug，现代 C++ 提倡用 `constexpr` 替代宏）。
- `#if / #ifdef`：根据条件，直接删掉不符合条件的代码块。

**注意：** 如果你觉得某个宏展开后行为很诡异，你可以用 `-E` 参数生成 `.i` 文件，亲眼看看它到底被替换成了什么鬼样子。

## 编译

**输入：** `main.i` **命令：** `g++ -S main.i -o main.s` **输出：** `main.s` (**汇编代码文件**)

**工作原理：** 真正的 C++ 编译器（如 GCC 的 `cc1plus`）登场。它要把 C++ 代码翻译成 CPU 架构对应的汇编语言（比如 x86 或 ARM）。

1. **词法/语法分析：** 把代码拆成 Token，构建抽象语法树 (AST)。如果少了分号，这里会报错。
2. **语义分析：** 检查类型匹配，模板实例化。
3. **极其恐怖的优化 (Optimization)：** 这是编译器最核心的技术！当你开了 `-O2` 或 `-O3` 时，编译器会在这里进行**函数内联 (Inlining)**、**死代码消除**、**循环展开**、**自动向量化 (SIMD)**。

**注意：** 这步的产物是 `.s` 文件，里面全是 `mov`, `push`, `add`, `jmp` 这种汇编指令。**它还不是机器能执行的二进制**，人类勉强还能看懂。

（符号表）：如果你的 `A.cpp` 里调用了 `B.cpp` 里的函数 `doSomething()`，编译器编译 `A.cpp` 时找不到这个函数的具体实现，怎么办？它会在 `A` 的产物里留一个“占位符（Symbol）”，标记为：“这里需要一个叫 `doSomething` 的地址，但我现在不知道，回头让别人来填”。

## 汇编

**输入：** `main.s` **命令：** `g++ -c main.s -o main.o` (或者用汇编器 `as`) **输出：** `main.o` 或 `main.obj` (**目标文件**，纯二进制机器码)

**工作原理：** 汇编器 (Assembler) 的工作其实极其枯燥且机械。它就是一个“查表器”。它把汇编代码里的 `add eax, 1` 直接查表，翻译成 CPU 认识的由 `0` 和 `1` 组成的机器指令（比如 `83 C0 01`）。

> 在日常写代码时，这一步的存在感为零。但在极致性能优化领域，可能采用内联汇编 (Inline Assembly) 技术：在极少数情况下，C++ 表达不出某些特定的 CPU 指令（比如某些特定的缓存预取指令），工程师会在 C++ 代码里直接写 `__asm__("...")` 强插汇编代码。

**Godbolt：** 工业界极其流行一个网站叫 **Compiler Explorer (Godbolt.org)**。工程师会在上面贴一段 C++ 代码，直接看编译器生成的汇编代码。以此来判断：我写的这个 `std::vector` 遍历，编译器到底有没有帮我做 SIMD 向量化加速？有没有多产生不必要的拷贝开销？

## 链接

**输入：** `main.o`, `math.o`, 以及各种第三方库 (`.a` / `.so`) **命令：** `g++ main.o math.o -o main.exe` (底层调用的其实是链接器 `ld`) **输出：** `main.exe` (最终可执行文件)

**工作原理：** 在第三步生成的 `.o` 文件里，如果 `main.o` 调用了 `math.o` 里的函数，`main.o` 里的汇编指令会留一个空白地址。链接器就像一个排版工人，它把所有的 `.o` 文件拼成一个连续的内存布局，然后把那些空白地址填上正确的偏移量。填不上，就报 `Undefined Reference`。

现在你有了 5000 个 `.o` 文件，里面全是一堆碎片化的机器码和“占位符”。

- **链接器 (Linker)** 登场！它的任务就是把这 5000 个 `.o` 文件缝合在一起。
- 它会去满世界找那些“占位符”对应的真实内存地址。
- **经典报错 1：`undefined reference / LNK2019`。** 链接器找遍了所有的 `.o` 文件，也没找到 `doSomething()` 的实现代码。通常是因为你忘记把 `B.cpp` 加入编译列表了。
- **经典报错 2：`multiple definition`。** 链接器找到了两份一模一样的 `doSomething()` 的实现（违反了 ODR，单一定义规则），它不知道该用哪个，直接罢工。
- **产物：** 最终的可执行文件（`.exe` 或 Linux 的 `a.out` / 动态链接库）。

# CMake



CMake 和编译模型的出现，就是为了解决“多文件协作”和“跨平台工程管理”的痛点。根据上面的流程，构建一个工程的时候，你得先生成所有的 `.o`（假设有 5000 个），然后再把它们 `link` 起来。如果只改了一个 `.cpp`，你肯定不想把另外 4999 个文件也重新编译一遍。

## Make / Makefile

为了解决这个问题，Linux 程序员发明了 `Make` 工具。你写一个叫 `Makefile` 的脚本，告诉它“谁依赖谁”。 一旦某个 `.cpp` 文件的修改时间比它的 `.o` 文件新，Make 就只重新编译这一个文件。 

**痛点：** Makefile 的语法极其恶心，而且它强绑定 Linux。在 Windows 下大家用的是 Visual Studio 的 `.sln` 和 `.vcxproj`。跨平台开发简直是噩梦。

## CMake

**CMake 最容易让人误解的一点：它本身根本不是构建工具！** 它不负责编译，也不负责链接。

CMake 是一个**“元构建系统 (Meta-Build System)”**。 你只需要用一套极其简洁的、统一的 CMake 语法写一个叫 `CMakeLists.txt` 的配置文件。

- 如果你在 Linux 下运行 CMake，它会帮你把 `CMakeLists.txt` **翻译**成一个完美的 `Makefile`。
- 如果你在 Windows 下运行，它会帮你**翻译**成一个完美的 Visual Studio 工程文件！
- 如果你追求极致编译速度，它可以帮你翻译成 `Ninja` 构建文件。

这就是工业界无脑选择 CMake 的原因：**Write once, build everywhere.**

### CMake 的地狱

CMake 诞生于 2000 年，最初只是个用来生成 Makefile 的宏替换脚本，连真正意义上的编程语言都算不上。后来为了适应各种奇怪的需求，硬生生地打了几十年的补丁，导致里面充斥着各种历史包袱、反直觉的变量作用域和极其丑陋的字符串匹配。

> “世界上只有两种 C++ 程序员：一种是讨厌 CMake 的，另一种是还没用过 CMake 的。”

### Modern CMake

在几年前的旧版 CMake 中，大家喜欢满天飞地定义“全局变量”（比如 include 路径全加上去）。但现代 CMake (CMake 3.0+) 引入了极其优雅的**面向对象思维：Target (目标)**。

在现代 CMake 眼里，世间万物只有两种 Target：

1. **Executable（可执行文件）**：最终跑起来的程序。
2. **Library（库）**：提供给别人用的代码集合（静态库 `.a/.lib` 或动态库 `.so/.dll`）。

我们来看一个最基础、但绝对标准的工业级 `CMakeLists.txt` 范例：



```CMake
# 1. 声明要求的 CMake 最低版本
cmake_minimum_required(VERSION 3.10)

# 2. 定义你的工程名字和语言
project(MyAwesomeServer CXX)

# 3. 造一个“库” (Target)
# 把 math_utils.cpp 编译成一个叫 MathLib 的静态库
add_library(MathLib STATIC math_utils.cpp)

# 4. 造一个“可执行文件” (Target)
# 把 main.cpp 编译成一个叫 ServerApp 的程序
add_executable(ServerApp main.cpp)

# 5. 缝合它们（核心！）
# 告诉 CMake：ServerApp 这个程序，需要链接 MathLib 这个库。
# 并且 MathLib 所有的公开头文件路径，也会自动传染给 ServerApp。
target_link_libraries(ServerApp PRIVATE MathLib)
```

这就是 CMake 的全部核心逻辑：**造 Target -> 给 Target 添加属性（头文件路径、编译选项） -> 把 Target 连在一起。**

核心概念：**依赖的传递性 (Transitive Usage Requirements)**。`target_link_libraries` 里的 **`PUBLIC`、`PRIVATE` 和 `INTERFACE` 到底有什么区别？**

假设有三个库：**底层库 B**，**中间库 A**，和**你的主程序 App**。 现在 `A` 用到了 `B`，而 `App` 用到了 `A`。

- **`PRIVATE` (私有依赖):** `A` 链接 `B` 时用了 `PRIVATE`。意思是：“我 `A` 只是在自己的 `.cpp` 源文件里悄悄用了 `B`，我的 `.h` 头文件里根本没提 `B`。” **结果：** `App` 链接 `A` 时，**不会**自动获得 `B` 的头文件和库。`B` 被完美隐藏了。这是最推荐的做法，能极大地加快编译速度！
- **`PUBLIC` (公开依赖):** `A` 链接 `B` 时用了 `PUBLIC`。意思是：“我 `A` 不仅自己用了 `B`，而且我还把 `B` 的头文件 `#include` 到了我自己的 `.h` 接口里！” **结果：** 既然 `App` 要用 `A`，就必定会包含 `A` 的头文件，从而被迫卷入 `B`。所以 CMake 会自动把 `B` 的路径也传染给 `App`。
- **`INTERFACE` (接口依赖):** 意思是：“我 `A` 根本没编译出任何机器码（比如我是一个纯模板库/Header-only 库），我只是一个空壳子，谁用我，谁就去链接 `B`。”

# 经典问题

## 关于头文件的致命陷阱

假设我写了一个 `math_tools.h`，里面直接定义了一个普通的函数：

```C++
// math_tools.h
int add(int a, int b) { 
    return a + b; 
}
```

然后我在 `main.cpp` 和 `calculate.cpp` 里都 `#include "math_tools.h"`。 在**编译**阶段会报错吗？在**链接**阶段会报错吗？为什么？应该怎么改才能修复这个问题？

编译不报错，只是把函数复制过去，链接报错，因为有两个相同的函数，无法确定链接哪一个。

如何修复？注意，不是 `#pragma once`（或者传统的 `#ifndef` 宏保护）！

> **为什么 `#pragma once` 救不了你？** `#pragma once`（或者传统的 `#ifndef` 宏保护）的作用**仅仅是防止同一个头文件被同一个 `.cpp` 文件包含多次**。
>
> 记住 C++ 编译器的特性：**它一次只处理一个 `.cpp` 文件（翻译单元）！**
>
> 1. 编译器处理 `main.cpp` 时，看到 `#include "math_tools.h"`，把 `add()` 函数的代码复制了进来。编译出一个 `main.o`，里面有一个 `add()` 的符号和实现。
> 2. 编译器处理 `calculate.cpp` 时，**它完全不知道 `main.cpp` 的存在**。它看到 `#include "math_tools.h"`，又把 `add()` 的代码复制了一遍。编译出一个 `calculate.o`，里面也有一个 `add()` 的实现。
> 3. **链接器**试图把 `main.o` 和 `calculate.o` 缝合，结果傻眼了：“怎么有两个 `add()` 的机器码？到底用哪个？” 直接报 **Multiple Definition (ODR违规)** 错误。`#pragma once` 在跨 `.cpp` 文件时是毫无作用的。

**正确的修复方案：**

- **方案 A（传统但最标准）：声明与实现分离。** 在 `math_tools.h` 里只写声明：`int add(int a, int b);`。然后在 `math_tools.cpp` 里写实现代码。这样 `add` 的机器码全局永远只有一份。
- **方案 B（现代 C++）：加上 `inline` 关键字。** 如果你非要把实现写在头文件里（模板函数和极短的函数通常这么干），你必须写成 `inline int add(int a, int b) { return a + b; }`。`inline` 不仅仅是“建议编译器内联展开”，它在链接层面还有一个极其重要的语义：**告诉链接器：“如果遇到多个同名的 `inline` 函数，随便挑一个保留，把其他的全扔掉，千万别报错！”**

## 关于静态库和动态库

在 CMake 里，我们可以用 `add_library(MathLib STATIC ...)` 生成静态库，或者用 `SHARED` 生成动态库。 

解释一下，**静态库（Static Library）** 和 **动态库（Dynamic/Shared Library）** 在最终生成可执行文件以及运行时，最大的区别是什么？

它们的核心区别在于**“链接发生的时机”和“物理拷贝”**。

**1. 静态库 (Static Library: `.a` / `.lib`) —— “打包带走”**

- **本质：** 它就是一个压缩包（类似 `.zip`），里面装着一堆 `.o` 目标文件。
- **链接时：** 链接器会像个强迫症一样，把你用到的静态库里的机器码，**原封不动地、物理地复制粘贴**到你最终的 `.exe` 可执行文件中。
- **优点：** 极其省心！你的程序是完全独立的（Standalone），发给任何人、在任何电脑上都能直接跑。
- **缺点：** 极其臃肿。如果 10 个程序都静态链接了 10MB 的体积库，硬盘和内存就会被浪费 100MB。

**2. 动态库 (Dynamic/Shared Library: `.so` / `.dll`) —— “打个欠条”**

- **本质：** 它是独立存在于操作系统中的二进制文件。
- **链接时：** 链接器**绝对不会**把动态库的代码复制到你的 `.exe` 里。它只在你的 `.exe` 里写下一张“欠条”（记录下库的名字和函数的占位符）。
- **运行时：** 当双击运行 `.exe` 时，操作系统的**加载器 (Loader)** 会接管。它看到“欠条”，就会去硬盘（比如 Windows 的 `C:\Windows\System32` 或 Linux 的 `/usr/lib`）里找那个 `.dll` 或 `.so` 文件，把它加载到内存里，然后把你的程序和库“动态”连通。
- **优点：** 极其节省空间。10 个程序哪怕都依赖 OpenCV 库，内存和硬盘里也永远只有一份 OpenCV 动态库的代码。
- **缺点：** 极其容易引发 **“DLL 地狱 (DLL Hell)”**。你把 `.exe` 发给客户，客户一运行，弹窗报错：“找不到 MSVCP140.dll”或者“缺少 libcrypto.so.1.1”。因为他的电脑上没装这些动态库，或者版本不对。

**CMake 中的选择：** 在现代 C++ 开发中，如果你写的是基础工具链，通常编成静态库；如果你做的是插件系统，或者项目极大需要加快编译速度，通常编成动态库。

> 静态 vs 动态的区别在“链接时机”，不是“是否内存地址固定”。更准确的表达是：
>
> - 静态库：链接时完成重定位，成为主程序的一部分
> - 动态库：运行时重定位，基址通常不固定（受 ASLR（Address Space Layout Randomization 地址空间布局随机化）影响）
>
> “内存偏移固定”并不是由“静态库 / 动态库”本身直接决定的，而是由**链接方式、重定位机制、是否启用 ASLR、是否使用 PIC 等因素**决定的。
>
> - 两者内部相对偏移本质上都是固定的（由编译产物决定）
> - 是否“固定地址”取决于 ASLR
> - 现代系统下两者的绝对地址通常都会变化
>
> 动态库在 Linux 下编译时确实需要加上 `-fPIC` (Position Independent Code，位置无关代码) 参数，因为动态库在运行时会被加载到内存的随机位置，它的内部跳转确实不能写死绝对地址。
>
> 第一，静态库（.a）
>
> 静态库在**链接阶段**被直接拷贝进最终可执行文件。
> 最终程序的代码段、数据段在生成可执行文件时已经完成重定位。
>
> - 如果系统**关闭 ASLR**，程序每次加载到内存的基地址是固定的，那么：
>   - 绝对地址是固定的
>   - 模块内偏移当然也是固定的
> - 如果系统**开启 ASLR（现代系统默认开启）**：
>   - 程序整体加载基址每次都会变化
>   - 但**模块内部的相对偏移仍然是固定的**
>   - 只是“基址 + 偏移”中的“基址”变了
>
> 因此，静态库并不是天然“内存地址固定”，它只是已经在链接时完成了重定位。
>
> 第二，动态库（.so / .dll）
>
> 动态库在**运行时由动态链接器加载**。
>
> 现代系统下通常：
>
> - 使用 PIC（Position Independent Code）
> - 启用 ASLR
>
> 结果是：
>
> - 动态库每次加载的基址可能不同
> - 库内部函数之间的相对偏移是固定的
> - 但“绝对地址”通常是变化的
>
> 如果关闭 ASLR，动态库也可以每次加载到相同地址。





