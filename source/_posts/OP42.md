---
title: 【OP42】CF-Flying Sort
date: 2023-04-07
tag: [dp]
category: [One Problem]
---

dp

<!--more-->



[Flying Sort (Hard Version)](https://codeforces.com/problemset/problem/1367/F2)

这题的目标是计算一个序列的最长不下降子序列的长度，并要求该子序列在值域上是连续的。（默认这个序列已经离散化过了）。

正解是一个有些复杂的 dp。

令 dp[i] 表示以 i 结尾的特殊子序列的最大长度。

设当前遍历到的数是 x，那么有这几种转移方式：

1. 所有的 x-1 已经都在前面出现了。那么 dp 就从x-1的第一次出现位置转移，中间加上所有的x-1
2. x-1 还没出现完。那么小于 x-1 的数就不能选了，否则值域就不连续了，剩下的 x-1没地方放了。所以只能从 x-1开始选
3. x之前出现过，那就直接接在上一个x的后面

这个状态转移看起来十分诡异，但是至少还比较好理解。

``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;
int f[N], a[N], b[N];
int cnt[N], tot[N], fir[N], las[N];
void solve() {
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
	int m = unique(b + 1, b + n + 1) - b - 1;
	for (int i = 1; i <= n; ++i) {
	    a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
	    cnt[a[i]]++;
	}
    for (int i = 1; i <= n; ++i) {
	    int x = a[i];
		if(tot[x - 1] == cnt[x - 1])
	        f[i] = max(f[i], f[fir[x - 1]] + tot[x - 1]);
	    if(las[x])
	        f[i] = max(f[i], f[las[x]] + 1);
		if(las[x - 1])
		    f[i] = max(f[i], tot[x - 1] + 1);
		f[i] = max(f[i], 1);	
		ans = max(ans, f[i]);
		las[x] = i;
		if(!fir[x]) fir[x] = i;
		tot[x]++;
	}
	cout << n - ans << endl;
	memset(f, 0, sizeof(int) * (n + 1));
	memset(cnt, 0, sizeof(int) * (n + 1));
	memset(tot, 0, sizeof(int) * (n + 1));
	memset(fir, 0, sizeof(int) * (n + 1));
	memset(las, 0, sizeof(int) * (n + 1));
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T = 1;
	cin >> T;
	while(T--) {
		solve();
	}
}
```

另一种做法更是令人震惊。

我们先对数排序，然后考虑一个数作为特殊子序列结尾的时候有什么性质。

前面放的数应当具有更小的下标，已经更小的值。

如果我们选择 x 作为结尾，而开头小于 x-1，那么所有的 x-1 都要用到

也就是说，类似于单调栈之类的想法，有些数如果现在就用不了了，那么以后也就再也用不了了

于是我们用一个栈维护 x 的下标，用一个集合维护 小于 x 的下标。

